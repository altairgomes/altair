c
c
c
c     PRAIA_light_curve_numerical_fit 
c
c
c     Purpose     
c
c     Fits nonlinear least-square curves of occultations and eclipses
c     between bodies with dimension and without atmosphere.
c
c     The fit model is numeric. The disk shapes of bodies and shadows are
c     numerically simulated for each instant of observation and the relative
c     fluxes computed. All sorts of patterns are accepted and rigorously
c     modelled, including solar phase angle and, in the case of  eclipses,
c     umbra and penumbra shadow paths.
c
c     The relative path between the disks are moddeled according to a
c     straight line, parametrized by the relative motion n, the impact
c     parameter b and the central instant of closest approach. The
c     illumination of disks is governed by the Lambert Law, with the albedo
c     ratios as the last parameter of the model.
c
c     For input, we need the observed light curve (PRAIA data format) and the 
c     ephemerides of the Sun, occulting and occulted bodies (eclipsing and
c     eclipsed). 
c
c     In this version, ephemerides are generated by NAIF/SPICE package. It is
c     assumed that the generated Sun and body positions are coherent for the
c     instants of the observations.
c
c
c     The proccess is run iterativelly, allowing for outlier points to be
c     eliminated one-by-one in a sigma-clip fashion over the (O-C) residuals
c     in flux ratio.
c
c
c     indexing 1 - occulted/eclipsed   body
c     indexing 2 - occulting/eclipsing body
c
c
c      Last modification: M. Assafin - 11/Jan/2011
c 
c


      IMPLICIT REAL *8 (A-H,O-Z)

      real*8 modVs1(100000),modVs2(100000)

      real*8 Fl(100000,2)

      real*8 gamaf
      integer*4 jnum3

      integer*8 icod,iv

      dimension ra1(100000),de1(100000),ra2(100000),de2(100000),
     ?ura2(100000),ude2(100000),dx(100000),dy(100000),
     ?ura3(100000),ude3(100000)

      dimension dj(100000),daju(100000),itira(100000),time(100000)

      dimension fluxo(100000),cflux(100000),ecflux(100000),
     ?efluxo(100000),flueph(100000)

      dimension col(100),ior(100000),iqua(4),ival(4),val(4),
     ?parama(4)

      dimension fase1(100000),fase2(100000),Dir1(100000),Dir2(100000),
     ?Dir3(100000),cosbeta(100000),ru(100000),rp(100000)

      dimension V1(100000,6),V2(100000,6),Vst(100000,6),Vu(100000,3),
     ?VV1(100000,3),VV2(100000,3)


      character*200 linha
      character*100 input
      character*50 outlog,output,lista,obcurv,plot,bola,tela
      character*1  isig

      hmsgms(i,j,a)=i+j/60.d0+a/3600.d0

c
c

      pi=0.3141592653589793d1
      grarad=pi/180.d0
      radgra=180.d0/pi

c
c     Auxiliary values
c


      ipar=4

      ipmax=100000
      idimcol=100
  
      ntira=0

      djzero=2400000.5D0
    
      iv=1

c
c     Zeroing values
c


      do i=1,ipmax
      time(i)=0.d0
      itira(i)=0
      ior(i)=i
      ra1(i)=0.d0
      ra2(i)=0.d0
      de1(i)=0.d0
      de2(i)=0.d0
      ura2(i)=0.d0
      ude2(i)=0.d0
      dj(i)=0.d0
      daju(i)=0.d0
      fluxo(i)=0.d0
      cflux(i)=0.d0
      ecflux(i)=0.d0
      efluxo(i)=0.d0
      flueph(i)=0.d0
      dx(i)=0.d0
      dy(i)=0.d0
      enddo

      do i=1,idimcol
      col(i)=0.d0
      enddo


c
c     Input file
c
c

      input=''
      input='PRAIA_light_curve_numerical_fit_20_20.dat'

c

      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' '
      write (*,1)
 1    format(1x,'PRAIA - Occultation/Eclipse Light Curve Numerical Fit')
 
      write (*,*) ' '
      write (*,*) ' '
      write (*,*) ' '

c

 2    format(a50)

      open (1,file=input)

c
c
c     ifit = 1    fitted curve from numerical model (initial guess of parameters
c                 based on LC;
c            2    not-fitted curve constructed from parameters estimated from LC;
c 
c

      read (1,*) ifit
      read (1,*) icod

c

      read (1,2) outlog
      read (1,2) output

      read (1,2) plot
      read (1,2) bola

c
c
c     Time output for fitted curve
c
c
c     kallotu -  optional time unit for LC output:
c                1=ss 2=mm 3=hh 4=dd (JD) 5=mm 6=yrs
c
c     kallrt  -  reference instant for optional time unit output:
c                1=Gregorian date  2=Julian Date; 3=Modified Julian Date
c
c


      read (1,*) kallotu

      read (1,*) kallrt


c
c     Computes Julian Date of reference instant for output fitted LC
c

      if (kallrt.eq.3) then 
      read (1,*) djmall
      djall=djmall+djzero
      endif

      if (kallrt.eq.2) then
      read (1,*) djall
      endif

      if (kallrt.eq.1) then
      read (1,*) iah,iam,as,idia,imes,iano
      fd=hmsgms(iah,iam,as)/24.d0
      call iau_CAL2JD (iano,imes,idia,djm0r,djmall,iflag)
      djmall=djmall+fd
      djall=djmall+djm0r
      endif

c
c     Ephemeris theory
c


      read (1,2) tela

c
c     Reads efemerides of involved bodies
c


      read (1,2) lista



c
c     Input observed light curve
c

      read (1,2) obcurv


c
c     Column with Julian Date from input observed LC 
c

      read (1,*) itime


c
c     Column with flux rate from input observed LC
c

      read (1,*) itflux

c
c     Column with flux rate error from input observed LC
c

      read (1,*) ieflux

c
c     Nth-degree of polynomial model for flattening observed LC background
c

      read (1,*) ngrau

      if (ngrau.lt.0)  ngrau=0
      if (ngrau.gt.21) ngrau=21

c
c     Indicates which model parameters will be effectivelly put to fitting
c

      do i=1,ipar
      read (1,*) iqua(i)
      enddo

c
c     Parameter initial guesses for fitting: automatic or user-defined
c
c     In the case of albedo ratios, the sense is ratio = target/reference.
c
c     target   : occulted or eclipsed object
c     reference: occulting object; in the case of eclipses it refers to the
c                object used as photometric reference (calibration) in the LC 
c
c


      do i=1,2
      read (1,*) ival(i),val(i)
      enddo



c
c     Central instant by the user (Modified Julian Date)
c

      read (1,*) jallrt

      if (jallrt.eq.3) then 
      read (1,*) ival(3),ejmall
      ejall=ejmall+djzero
      endif

      if (jallrt.eq.2) then
      read (1,*) ival(3),ejall
      endif

      if (jallrt.eq.1) then
      read (1,*) ival(3),iah,iam,as,idia,imes,iano
      fd=hmsgms(iah,iam,as)/24.d0
      call iau_CAL2JD (iano,imes,idia,ejm0r,ejmall,iflag)
      ejmall=ejmall+fd
      ejall=ejmall+ejm0r
      endif

      val(3)=ejall-djzero


c
c     Relative velocity by the user: arcsec/s to arcsec/(Julian Date)
c


      read (1,*) ival(4),val(4)


      val(4)=val(4)*86400.d0

c
c     Step sizes of parameters for non-linear LS
c

      do i=1,ipar
      read (1,*) parama(i)
      enddo
 

c
c     Radius (Km)
c


      read (1,*) r2
      read (1,*) r1

c
c     Number of iterations for fitting
c

      read (1,*) iiconv


c
c     |O-C| threshold in normalized flux units
c

      read (1,*) corte


c
c     Spatial resolution of LC numerical model (km)
c

      read (1,*) pre

c
c     Log file
c

      rewind (1)

c

      open (2,file=outlog)

      write (2,*) ' '
      write (2,*) ' '
      write (2,*) ' '
      write (2,1)
      write (2,*) ' '
      write (2,*) ' '
      write (2,*) ' '

c


 4    read (1,5,end=6) linha
 5    format(a200)
      if (linha(1:1).eq.'*') go to 6
      write (2,5) linha
      go to 4

 6    write (2,5) linha

      close (1)

      write (2,*)
      write (2,*)
      write (2,*)

      if (icod.eq.1) then
      write (2,*) 'Event is an occultation.' 
      write (2,*)
      write (2,*)
      else
      write (2,*) 'Event is an eclipse.' 
      write (2,*)
      write (2,*)
      endif

c
c     Finished reading input info
c

      close (1)

c
c     Reads observed input LC
c

      icol=max0(itime,itflux,ieflux)


      write (*,*)
      write (*,*)


      open (3,file=obcurv)

      do i=1,ipmax
      read (3,*,end=10) (col(j),j=1,icol)

      dj(i)=col(itime)
      cflux(i)=col(itflux)
      ecflux(i)=col(ieflux)
      
      enddo

 10   close (3)

      nptos=i-1


c
c     Extracts efemerides
c


      call ephem (lista,daju,V1,V2,Vst,ra1,de1,ra2,de2,nep)

      if (nptos.ne.nep) then
      write (*,*)
      write (*,*) ' Number of LC points do not match number of ephemeris
     ? points. Exiting ...'
      write (*,*)
      stop
      endif


c
c     Computs instants in optional time units defined by the user
c


      do i=1,nptos


      if (kallotu.eq.1) time(i)=(dj(i)-djall)*86400.d0
      if (kallotu.eq.2) time(i)=(dj(i)-djall)*1440.d0
      if (kallotu.eq.3) time(i)=(dj(i)-djall)*24.d0
      if (kallotu.eq.4) time(i)=(dj(i)-djall)
      if (kallotu.eq.5) time(i)=(dj(i)-djall)/30.5d0
      if (kallotu.eq.6) time(i)=(dj(i)-djall)/365.25d0

      enddo

      call bordo (Fl,jnum3)
c      do jnhn = 1,jnum3+1
c      write(*,*) Fl(jnhn,1),Fl(jnhn,2)
c      end do
c      stop

c
c     First estimate of central instant and minimum LC flux
c

      distan=1.d14

      do i=3,nptos-2
      dis=dmax1(cflux(i-2),cflux(i-1),cflux(i),cflux(i+1),cflux(i+2))
      if (dis.lt.distan) then
      distan=dis
      j=i
      endif
      enddo


      fm=distan
      djmin=dj(j)


c
c     Topocentric distance in km to bodies at central instant
c

      distan=1.d14

      do i=1,nptos
      dis=dabs(dj(i)-djmin)
      if (dis.lt.distan) then
      j=i
      distan=dis
      endif
      enddo

      distan=dsqrt(V1(j,1)**2+V1(j,2)**2+V1(j,3)**2)
      idjmin=j



c
c     Auxiliary data for Sun phase angle, umbra and penumbra computations
c

      iv=nptos

      call fase (iv,dj,V1,V2,Vst,fase1,fase2,Dir1,Dir2,Dir3,
     ?cosbeta,ModVs1,ModVs2,Vu)

c
c     Computes (RA,Dec) of occulting/eclipsing and occulted/eclipsed bodies, and
c     oculting/eclipsing body umbra projected in the sky plane
c

      do i=1,nptos
      do j=1,3
      VV1(i,j)=V1(i,j)
      VV2(i,j)=V2(i,j)
      enddo
      enddo

      call radec (nptos,Vu,ura2,ude2)
      call radec (nptos,VV1,ra1,de1)
      call radec (nptos,VV2,ra2,de2)


c
c     Fits LC. Numerical model with non-linear LS (adapted Marquardt Method)
c

      ktira=0

 20   continue

      call light (ifit,icod,ngrau,iiconv,iqua,ival,val,ior,
     ?nptos,idjmin,djmin,fm,dj,time,ra1,ra2,de1,de2,ura2,ude2,
     ?r1,r2,ru,rp,fase1,fase2,Dir1,Dir2,Dir3,cosbeta,distan,ModVs1,
     ?ModVs2,cflux,ecflux,fluxo,efluxo,flueph,ralb,pacto,tzero,vel,
     ?fundo,eralb,epacto,etzero,evel,efundo,parama,itira,corte,pre,dx,
     ?dy,tela,Fl,jnum3,gamaf)



      do i=1,nptos
      if (itira(i).ne.0) ntira=ntira+1
      enddo

      if (ktira.ne.ntira) then

      ktira=ntira
      ntira=0

      rewind (2)


 30   read (2,5) linha
      if (linha(1:1).eq.'*') go to 35
      go to 30

 35   write (2,*)
      write (2,*)
      write (2,*)

      go to 20

      endif

c

 40   continue


      write (2,*)
      write (2,*)

      write (2,*)' Final general adjustment information:'
      write (2,*)
      write (2,*)

      write (2,*)
      write (2,*)
      npata=nptos-ntira
      write (2,*) 'Total number of points              = ',nptos
      write (2,*) 'Total number of fitted points       = ',npata
      write (2,*) 'Number of eliminated points         = ',ntira  
      write (2,*)
      write (2,*)

      close (2)

c
c     Writes fitted LC.
c


      open (7,file=output)


      do i=1,nptos


      dflu=cflux(i)-fluxo(i)
      dflue=cflux(i)-flueph(i)

c
c     Labels the eliminated points above the |O-C| threshold defined by
c     the user
c

      if (itira(i).eq.0) then
      lab=203
      else
      lab=40
      endif

      write (7,60) lab,i,dflu,time(i),fluxo(i),efluxo(i),cflux(i),
     ?ecflux(i),dj(i),dflue,flueph(i)
 60   format(1x,i3.3,1x,i7,9(1x,f16.8))

      enddo

      close (7)


c
c     Writes files for plotting relative trajectory of (2) with respect to (1)
c


      open (9,file=bola)


c
c     Writes file with occulted/eclipsed body circunference for projection of shadow
c


      dpi=2.0*pi

      erro=dabs(datan2(pre,r1))

      a=erro/2.d0

 64   a=a+erro

      if (a.gt.dpi) go to 65

      x=r1*dcos(a)
      y=r1*dsin(a)

      write (9,*) x,y

      go to 64

 65   close (9)

c
c     Writes file with occulting body trajectory. Upper and lower borders are
c     displayed. In the case of eclipses, the upper and lower borders of the umbra
c     and penumbra are drawn.
c


      open (9,file=plot)

      do i=1,nptos

      if (icod.eq.2) then
      ri=ru(i)
      re=rp(i)
      else
      ri=r2
      re=r2
      endif
 
      write (9,70) dx(i),dy(i),dy(i)-ri,dy(i)+ri,dy(i)-re,dy(i)+re
 70   format(6(1x,f16.8))

      enddo

      close (9)

c


      write (*,*)
      write (*,*)
      write (*,*) ' Program terminated successfully.'
      write (*,*)
      write (*,*)

    
      end




c
c
c
c     Subroutine ephem
c
c
c     Reads ephemerides of involved bodies, including the Sun.
c
c     The data is also used to compute the Sun phase angle and
c     projected umbra and penumbra in the case of eclipses.
c
c
c     V1 - topocentric vector of occulted/eclipsed body
c          1 - X
c          2 - Y
c          3 - Z
c          4 - dX/dt
c          5 - dY/dt
c          6 - dZ/dt
c
c     V2 - topocentric vector of occulting/eclipsing body
c          1 - X
c          2 - Y
c          3 - Z
c          4 - dX/dt
c          5 - dY/dt
c          6 - dZ/dt
c
c     Vst - topocentric vector of the Sun
c          1 - X
c          2 - Y
c          3 - Z
c          4 - dX/dt
c          5 - dY/dt
c          6 - dZ/dt
c
c     ra1  - RA  of occulted/eclipsed body
c     de1  - Dec of occulted/eclipsed body
c
c     ra2  - RA  of occulting/eclipsing body
c     de2  - Dec of occulting/eclipsing body
c
c
c
c     Last modification: M. Assafin  01/Nov/2010
c
c

      subroutine ephem (lista,daju,V1,V2,Vst,ra1,de1,ra2,de2,nep)


      implicit real *8 (a-h,o-z)


      dimension ra1(100000),de1(100000),ra2(100000),de2(100000),
     ?daju(100000)

      dimension V1(100000,6),V2(100000,6),Vst(100000,6)

      character *50 lista
      character*1 isig1,isig2
      character*3 metab(12),kmes


      data metab/'JAN','FEB','MAR','APR','MAY','JUN','JUL',
     ?'AUG','SEP','OCT','NOV','DEC'/


      hmsgms(i,j,a)=i+j/60.d0+a/3600.d0
c
      pi=0.3141592653589793d1
      grarad=pi/180.d0
      radgra=180.d0/pi
c

      idmax=100000


c
c     Reads input ephemeris
c

      open (3,file=lista)

      read (3,*)
      read (3,*)
 

      do i=1,idmax
c20   continue
c     read(3,30,err=20,end=40) iutano,kmes,iutdia,iuth,iutm,sut,
      read(3,30,end=40) iutano,kmes,iutdia,iuth,iutm,sut,
     ?(V1(i,j),j=1,6),(V2(i,k),k=1,6),(Vst(i,l),l=1,6),iah1,iam1,sa1,
     ?isig1,idg1,idm1,ds1,iah2,iam2,sa2,isig2,idg2,idm2,ds2

 30   format(i4,1x,a3,1x,i2,1x,i2,1x,i2,1x,f6.3,3X,
     ?3F18.4,1X,3F10.5,3X,3F18.4,1X,3F10.5,3X,
     ?3F18.4,1X,3F10.5,
     ?2(3x,2(i2,1x),f7.4,3x,a1,2(i2,1x),f6.3))


      ra1(i)=15.d0*hmsgms(iah1,iam1,sa1)
      de1(i)=hmsgms(idg1,idm1,ds1)
      if (isig1.eq.'-') de1(i)=-de1(i)

      ra2(i)=15.d0*hmsgms(iah2,iam2,sa2)
      de2(i)=hmsgms(idg2,idm2,ds2)
      if (isig2.eq.'-') de2(i)=-de2(i)


      do j=1,12
      if (metab(j).eq.kmes) go to 35
      enddo
 35   iutmes=j


c
c     Computes Julian Dates
c

      fd=hmsgms(iuth,iutm,sut)/24.d0

      call iau_CAL2JD (iutano,iutmes,iutdia,djm0,djm,iflag)

      djm=djm+fd
            
      daju(i)=djm+djm0

      enddo  

c

 40   nep=i-1

      close (3)


      return
      end


c
c
c     Subrotine light
c
c
c     Fits LC.
c
c     For the sake of notation simplicity, we refer to bodies as "occulting"
c     and "occulted" in the eclipse case too. Note, however, that the albedo
c     of the umbra disk is zero.
c
c     The proccess starts by flattening and nornalizing the observed LC. This
c     way, the LC background flux ratio outside the event is set to 1. Inside
c     the event, the flux ratio takes the sense:
c
c
c     F=(occulting_flux+occulted_flux)/(total_outside_flux_occulting+occulted)
c
c
c     with F = 1 outside the event. 
c
c
c     The polynomial that flats the LC background is adjusted for points
c     outside the event. These points are estimated from the observed LC.
c     The polynomial takes the form: 
c
c
c                 P = A + Bt + Ct**2 + ...
c     
c
c     After this adjustment, the original observed LC is divided point by
c     point by P. The resulting flux ratio is thus normalized and the LC
c     background outside the event is flatted.
c
c
c  
c     Initial guesses for the non-LS fit to the normilized LC are estimated
c     for the following parameters:
c
c     - albedo ratio
c     - impact parameter
c     - central instant
c     - relative velocity
c
c
c     Each parameter guess is explained as follows.
c
c
c
c     1. Albedos
c
c        Furnished by the user. Albedos can be extracted from the literature
c        or directly from photometric observations.
c       
c        If not furnished by the user, it is computed from the flux ratio of the
c        LC extremes and from the radius furnished by the user.
c
c
c     2. Impact parameter
c
c        It is the least apparent distance in the plane of the sky between
c        the occulting and occulted body. It can be furnished by the user or
c        estimated from the LC. Estimation is based on the flux ratio drop
c        in the LC with respect to its background. The drop is proportional to
c        the affected area of the occulted/eclipsed body, and this furnishes
c        an approximate estimate for the probable minimum distance.
c
c
c     3. Central instant
c
c        Instant associated to the impact parameter. Also estimated from
c        the LC (point of maximum drop in LC).
c
c
c     4. Relative velocity
c
c        It is the relative velocity of the occulting body with respect to
c        the occulted one, tangent to the point of least distance between
c        them (impact parameter), in the plane of the sky. Estimated from
c        the LC. The instants of ingress and egress are estimated from the LC.
c        This distance is then related to the diameter of the occulted/eclipsed
c        body and a relative velocity value is obtained.
c
c
c     All these parameters can be also estimated from an ephemeris (theory). The
c     program allows for plotting curves derived from the LC-based parameters's
c     initial guesses (useful to see if initial guesses are reasonable), or from
c     ephemeris-based parameters (useful to compare the LC fit to pre-established
c     theories).
c
c
c
c     In the case of eclipses, all the above parameters refer to the shadow
c     disk projected in the sky plane.
c
c
c
c     The subroutine with the effective fitting proccess is curfit.
c     (see details inside).
c
c
c     After the fitting, parameters and their error estimates are furnished.
c     Also given are correlations and mean error of fit. The fitted flux
c     ratios corresponding to each observed point is stored, as well as the
c     related (O-C) flux residuals.
c
c   
c
c
c     Variables of the program:
c
c
c       dj     - Julian Date of observation
c       time   - instant of observation (optional user units for LC plotting)
c
c       iv     - number of points furnished to computing numerical model
c                (default = 1 point; evaluates each observation at a time)
c       pre    - scale factor km/pixel (surface resolution of numerical model)
c	fase1  -  vector with phase angles for occulted/eclipsed satellite 1 for
c                 each observation
c	fase2  -  vector with phase angles for occulting/eclipsing satellite 2 for
c                 each observation
c	Dir1   -  vector with inclination angles of line containing semi-ellipse focii
c                 of occulted/eclipsed satellite 1
c	Dir2   -  vector with inclination angles of line containing semi-ellipse focii
c                 of occulting satellite 2
c	Dir3   -  vector with inclination angles of line containing semi-ellipse focii
c                 of eclipsing shadow
c	cosbeta - vector containing angles between satellite heliocentric vectors for
c                  computing distances between
c                  eclipsed satellite and Sun
c       modVs1 - distance from occulted/eclipsed satellite 1 to Sun
c       modVs2 - distance from occulting/eclipseing satellite 2 to Sun
c
c       ru     - umbra radius of eclipsing body (km)
c       rp     - penumbra radius of eclipsing body (km)
c
c
c     cflux      - observed LC    
c     ecfluxo    - error flux (from photometry) of observed LC
c
c     fluxo      - fitted LC
c     efluxo     - standard error of fitted LC (point by point)
c
c     flueph     - flux from theoretical LC generated from ephemeris-based parameters
c
c     ralb       - fitted albedo ratio
c     eralb      - error of fitted albedo ratio
c 
c     pacto      - fitted impact parameter (arcsec)
c     epacto     - error of fitted impact parameter (arcsec)
c
c     tzero      - fitted central instant (JD)
c     etzero     - error of fitted central instant (JD)
c
c     vel        - fitted relative velocity (arcsec/JD)
c     evel       - error of fitted relative velocity (arcsec/JD)
c
c     fundo      - fiited polynomial model for flattening/normalizing
c                  LC background
c     efundo     - error of fitted polynomial model LC background
c
c
c     idjmin     - approximate LC point of minimum flux ratio
c     djmin      - instant at thar LC point
c     fm         - estimated minimum LC flux
c
c
c     iqua       - which parameters are to be effectivelly fitted ?
c                  1 = fit
c                  0 = do not fit (take user-defined value)
c
c
c     iiconv     - internal number of LC non-linear LS fitting iterations
c
c
c     ival       - initial guess mode for parameters (1 = automatic, 2 = user)
c     val        - initial guess values for parameters (effective if ival
c                                                       is not equal to 1)
c
c     icod       - key 
c                   1 - occultation numerical model
c                   2 - eclipse numerical model
c
c     ifit       -  1 -> generate LC by non-linear LS
c                   2 -> generate LC by initial guess parameters
c  
c
c     itira      - 0 -> observation entered fitting
c                  1 -> observation eliminated from fitting, |O-C| 
c                       above threshold
c
c     pre        - spatial resolution of LC numerical model (km)
c
c
c
c     Last modification: M. Assafin.   19/Nov/2010
c
c


      subroutine light (ifit,icod,ngrau,iiconv,iqua,ival,val,ior,
     ?nptos,idjmin,djmin,fm,dj,time,ra1,ra2,de1,de2,ura2,ude2,
     ?r1,r2,ru,rp,fase1,fase2,Dir1,Dir2,Dir3,cosbeta,distan,modVs1,
     ?modVs2,cflux,ecflux,fluxo,efluxo,flueph,ralb,pacto,tzero,vel,
     ?fundo,eralb,epacto,etzero,evel,efundo,parama,itira,corte,pre,dx,
     ?dy,tela,Fl,jnum3,gamaf)


      implicit real *8 (a-h,o-z)

      real*8 modVs1(100000),modVs2(100000)

      real*8 Fl(100000,2)

      real*8 gamaf

      integer*4 jnum3

      integer*8 iv,icod

      dimension ra1(100000),de1(100000),dx(100000),dy(100000)
      dimension ra2(100000),de2(100000)
      dimension ura2(100000),ude2(100000)
      dimension dj(100000),d(100000),itira(100000),time(100000)

      dimension fluxo(100000),cflux(100000),efluxo(100000),
     ?ecflux(100000),flueph(100000)
      dimension ior(100000),xest(100000),xp(100000),coef(21)
      dimension sigmaa(4),deltaa(4),param(4),parama(4),array(21,21),
     ?xrray(21,21),deriv(4),iqua(4),ival(4),val(4)

      dimension fase1(100000),fase2(100000),Dir1(100000),Dir2(100000),
     ?Dir3(100000),cosbeta(100000),ru(100000),rp(100000)

      character*10 label(4)

      character*50 tela


      common /a7/array
      common/a14/ierro

c

      pi=0.3141592653589793d1
      grarad=pi/180.d0
      radgra=180.d0/pi

c

      iv=1

      ipar=4
      ipmax=100000

      au=149597870.691d0
      djzero=2400000.5D0

c

      djmin=djmin-djzero

      r1arc=dabs(radgra*3600.d0*datan2(r1,distan))
      r2arc=dabs(radgra*3600.d0*datan2(r2,distan))

      prec=dabs(radgra*3600.d0*datan2(pre,distan))

c

      do i=1,21
      coef(i)=0.d0
      do j=1,21
      array(j,i)=0.d0
      enddo
      enddo

      do i=1,ipar
      deriv(i)=0.d0
      enddo


c
c     Convert Julian Dates to Modified Julian Date to avoid error propagation
c


      do i=1,nptos
      dj(i)=dj(i)-djzero
      enddo




c
c     Rough estimate of beggining and end of event
c

      x=0.d0
      s=0.d0
      n=0

      ix1=nptos/10.d0
      ix2=nptos-ix1

      do i=1,ix1
      n=n+1
      x=x+cflux(i)
      s=s+cflux(i)**2
      enddo

      do i=ix2,nptos
      n=n+1
      x=x+cflux(i)
      s=s+cflux(i)**2
      enddo

      call desvio (n,x,s)


c
c     Beggining of event
c

      do i=1,nptos
      j=idjmin-i
      if (cflux(j).gt.x) go to 1
      enddo

 1    i1=j

c
c     End of event
c

      do i=1,nptos
      j=idjmin+i
      if (cflux(j).gt.x) go to 2
      enddo

 2    i2=j


c
c     Event duration estimates
c

      j1=i1
      j2=i2

      jj1=j1
      jj2=j2
      jm=idjmin


      dinie=dj(j1)
      dfime=dj(j2)

      durae=dabs(dfime-dinie)*86400.d0


c
c     Refines central instant
c

      djmin=0.d0
      ss=0.d0

      do i=j1,j2
      djmin=djmin+(1.d0/cflux(i))*dj(i)
      ss=ss+1.d0/cflux(i)
      enddo

      djmin=djmin/ss

      ss=1.d14

      do i=j1,j2
      aux=dabs(dj(i)-djmin)
      if (aux.lt.ss) then
      ss=aux
      idjmin=i
      endif
      enddo
   
      jm=idjmin


      tzero=djmin


c
c     Central instan input by user
c

      if (ival(3).ne.1) tzero=val(3)



c
c
c     Estimates LC background parts to the left and to the right of
c     the event.
c 
c     Only 3/4 of estimated background lenghts are used for safety.
c
c     Left : 1 to ii1
c     Right: i2 to nptos
c

      ii1=i1*0.75
      ii2=(nptos-i2)*0.75
      ii2=nptos-ii2

      i1=ii1
      i2=ii2

      if (i1.lt.1) i1=15
      if (i2.gt.nptos) i2=nptos-15


      dj1=dj(i1)
      dj2=dj(i2)



c
c     Estimates LC background coefficients by N-degree polynom fitted
c     to estimated LC background parts
c



      n=0

      do i=1,i1
      if (itira(i).eq.0) then
      n=n+1
      xest(n)=dj(i)
      xp(n)=cflux(i)
      endif
      enddo

      do i=i2,nptos
      if (itira(i).eq.0) then
      n=n+1
      xest(n)=dj(i)
      xp(n)=cflux(i)
      endif
      enddo


      call solfun (ngrau,n,xest,xp,coef,sig)



c
c     Write computed initial values in log file
c

      write (2,*)
      write (2,*)
      write (2,*)
      write (2,*) 'Parameters to fit: '
      write (2,*)
      write (2,*)
      write (2,*) '1 = fit .:. 0 = not to fit ' 
      write (2,*)
      write (2,*)

      write (2,*)
      write (2,*) 'occulting/occulted albedo ratio : ',iqua(1)
      write (2,*) 'impact parameter                : ',iqua(2)
      write (2,*) 'central instant                 : ',iqua(3)
      write (2,*) 'relative tangent velocity       : ',iqua(4)
      write (2,*)
      write (2,*)


      write (2,*)
      write (2,*)
      write (2,*) 'Non-linear L.S. solution parameters: initial evaluate
     ?d values. '
      write (2,*)

      write (2,*)
      write (2,*)
      write(2,*)'Estimated (beggining, middle, end) of observed event: '
      write (2,*) 

c

      aux=dinie

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=dinie+djzero

      write (2,10) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
 10   format(' Beggining    (h,m,s,d,mo,yr), JD = ',2(i2.2,1x),f6.3,1x,
     ?i2.2,1x,i2.2,1x,i4,4x,f16.8)

      write (2,11) j1,time(j1)
 11   format(' LC point = ',i6,' .:. LC (plot time units) = ',f16.3)

      write (2,*) 

c

      aux=tzero

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=tzero+djzero

      write (2,12) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
 12   format(' Middle       (h,m,s,d,mo,yr), JD = ',2(i2.2,1x),f6.3,1x,
     ?i2.2,1x,i2.2,1x,i4,4x,f16.8)

      write (2,11) idjmin,time(idjmin)

      write (2,*) 

c


      aux=dfime

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=dfime+djzero

      write (2,13) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
 13   format(' End of event (h,m,s,d,mo,yr), JD = ',2(i2.2,1x),f6.3,1x,
     ?i2.2,1x,i2.2,1x,i4,4x,f16.8)

      write (2,11) j2,time(j2)


      write (2,*) 

      write (2,15) durae
 15   format(' Initial estimated event duration (seconds) = ',f16.3)

      write (2,*) 
      write (2,*) 
      write (2,*) 

c

      write (2,*)
      write (2,*) 'Curved background from observed LC: ' 
      write (2,*)
      write (2,*)
      write (2,*) 'F = A + B.t + C.t^2 + ...'
      write (2,*)
      write (2,*) '(t = Julian Date)'
      write (2,*)
      write (2,*) 'Polynomial degree = ',ngrau
      write (2,*)

      write (2,*)
      write (2,*) 'LC intervals for background computations (JD): '
      write (2,*) 
      iiii=1
      write (2,20)' LC point = ',iiii,'  .:. t1 = ',dj(1)+djzero,'  .:. 
     ?LC time unit = ',time(iiii)
 20   format(a11,i6,a11,f16.8,a21,f16.3)
      write (2,20) ' LC point = ',i1,'  .:. t2 = ',dj(i1)+djzero,'  .:. 
     ?LC time unit = ',time(i1)
       write (2,*)
      write (2,*) 'and '
      write (2,*)
      write (2,20) ' LC point = ',i2,'  .:. t3 = ',dj(i2)+djzero,'  .:. 
     ?LC time unit = ',time(i2)
      write (2,20)' LC point = ',nptos,'  .:. t4 = ',dj(nptos)+djzero,
     ?'  .:. LC time unit = ',time(nptos)
      write (2,*)

     
      write (2,*)
      write (2,*) 'Computed coeficients: '
      write (2,*)
      write (2,*)

      nterms=ngrau+1

      do i=1,nterms
      k=i-1
      write (2,*) 't^',k,' => ',coef(i)
      enddo

      write (2,*)
      write (2,*)
      write (2,*) 
      write (2,*) 'sigma (O-C) in flux ratio = ',sig
      write (2,*) 
      write (2,*) 



c
c     Flattens and normalizes observed LC with fitted N-degree
c     background polynomial model
c


      do i=1,nptos
      f=0.d0
      do k=1,nterms
      f=f+coef(k)*dj(i)**(k-1)
      enddo

c     write (*,*) 'i, cflux, f, dif = ',i,cflux(i),f,cflux(i)-f

      cflux(i)=cflux(i)/f

      enddo




c
c     Checks flatted LC background and normalizes it again.
c     Background average must be 1.0
c

      n=0

      xvam=0.d0
      xvas=0.d0

      do i=1,i1
      if (itira(i).eq.0) then
      n=n+1
      xvam=xvam+cflux(i)
      xvas=xvas+cflux(i)**2
      endif
      enddo

      do i=i2,nptos
      if (itira(i).eq.0) then
      n=n+1
      xvam=xvam+cflux(i)
      xvas=xvas+cflux(i)**2
      endif
      enddo


      call desvio (n,xvam,xvas)


      do i=1,nptos
      cflux(i)=cflux(i)/xvam
      enddo
      
c
c     Store statistics for flatted LC background
c

      n=0

      xvam=0.d0
      xvas=0.d0

      do i=1,i1
      if (itira(i).eq.0) then
      n=n+1
      xvam=xvam+cflux(i)
      xvas=xvas+cflux(i)**2
      endif
      enddo

      do i=i2,nptos
      if (itira(i).eq.0) then
      n=n+1
      xvam=xvam+cflux(i)
      xvas=xvas+cflux(i)**2
      endif
      enddo


      call desvio (n,xvam,xvas)

c

      fundo=xvam
      fundo2=xvas

      write (2,*)
      write (2,*)
      write (2,*) 'Flatted background after LC normalization: ' 
      write (2,*)
      write (2,*)
      write (2,*) 'F = cte = ',xvam

      write (2,*) 
      write (2,*) 'sigma (O-C) of F (normalized flux ratio) = ',xvas
      write (2,*) 
      write (2,*) 


c
c     Estimates relative velocity and impact parameter
c



      if (icod.eq.2) then
      ralb=1.d0
      else
      ralb=val(1)
      endif


      param(1)=ralb
      param(3)=tzero
      param(4)=2.d0*(r1+r2)/(dfime-dinie)


      pac=r1/2.d0

c
c     Evokes model to compute penumbra radius
c


      call funcao (iv,r1,r2,pac,param(4),dj(jm),param(3),icod,pre,
     ?param(1),flu,fase1(jm),fase2(jm),Dir1(jm),Dir2(jm),Dir3(jm),
     ?cosbeta(jm),modVs1(jm),modVs2(jm),ru(jm),rp(jm),Fl,jnum3,gamaf)


c
c     Estimates relative velocity from LC  ("/s)
c

      r2p=rp(jm)
      r2parc=radgra*3600.d0*dabs(datan2(r2p,distan))


      if (icod.eq.1) then

      vel=2.d0*(r1arc+r2arc)/(dfime-dinie)

      else

      vel=2.d0*(r1arc+r2parc)/(dfime-dinie)

      endif


      vel=vel/86400.d0



c
c     Estimates impact parameter
c
c



      fjm=cflux(jm)
      fj1=cflux(jj1)
      fj2=cflux(jj2)

      jj3=(jm+jj1)/2
      jj4=(jm+jj2)/2

      fj3=cflux(jj3)
      fj4=cflux(jj4)



      flum=1.d14
      pacto=0.d0
      pac=-pre/2.d0
      dismax=r1+r2

c
 

 25   continue

      pac=pac+pre

      if (pac.gt.dismax) go to 27

      call funcao (iv,r1,r2,pac,param(4),dj(1),param(3),icod,pre,
     ?param(1),f1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru(1),rp(1),Fl,jnum3,gamaf)

      call funcao (iv,r1,r2,pac,param(4),dj(nptos),param(3),icod,pre,
     ?param(1),f2,fase1(nptos),fase2(nptos),Dir1(nptos),Dir2(nptos),
     ?Dir3(nptos),cosbeta(nptos),modVs1(nptos),modVs2(nptos),ru(nptos),
     ?rp(nptos),Fl,jnum3,gamaf)



      flmax=dmax1(f1,f2)

      dflu=0.d0


      call funcao (iv,r1,r2,pac,param(4),dj(jm),param(3),icod,pre,
     ?param(1),flu,fase1(jm),fase2(jm),Dir1(jm),Dir2(jm),Dir3(jm),
     ?cosbeta(jm),modVs1(jm),modVs2(jm),ru(jm),rp(jm),Fl,jnum3,gamaf)

      flu=flu/flmax

      dflu=dflu+dabs(flu-fjm)


      call funcao (iv,r1,r2,pac,param(4),dj(jj1),param(3),icod,pre,
     ?param(1),flu,fase1(jj1),fase2(jj1),Dir1(jj1),Dir2(jj1),Dir3(jj1),
     ?cosbeta(jj1),modVs1(jj1),modVs2(jj1),ru(jj1),rp(jj1),Fl,jnum3,
     ?gamaf)

      flu=flu/flmax


      dflu=dflu+dabs(flu-fj1)


      call funcao (iv,r1,r2,pac,param(4),dj(jj2),param(3),icod,pre,
     ?param(1),flu,fase1(jj2),fase2(jj2),Dir1(jj2),Dir2(jj2),Dir3(jj2),
     ?cosbeta(jj2),modVs1(jj2),modVs2(jj2),ru(jj2),rp(jj2),Fl,
     ?jnum3,gamaf)

      flu=flu/flmax


      dflu=dflu+dabs(flu-fj2)


      call funcao (iv,r1,r2,pac,param(4),dj(jj3),param(3),icod,pre,
     ?param(1),flu,fase1(jj3),fase2(jj3),Dir1(jj3),Dir2(jj3),Dir3(jj3),
     ?cosbeta(jj3),modVs1(jj3),modVs2(jj3),ru(jj3),rp(jj3),Fl,
     ?jnum3,gamaf)

      flu=flu/flmax


      dflu=dflu+dabs(flu-fj3)


      call funcao (iv,r1,r2,pac,param(4),dj(jj4),param(3),icod,pre,
     ?param(1),flu,fase1(jj4),fase2(jj4),Dir1(jj4),Dir2(jj4),Dir3(jj4),
     ?cosbeta(jj4),modVs1(jj4),modVs2(jj4),ru(jj4),rp(jj4),Fl,
     ?jnum3,gamaf)

      flu=flu/flmax


      dflu=dflu+dabs(flu-fj4)



      if (dflu.lt.flum) then
      flum=dflu
      pacto=pac
      endif

      go to 25


 27   continue


      pacto=radgra*3600.d0*dabs(datan2(pacto,distan))





c
c     Estimates input by the user for impact parameter
c     and relative velocity
c
c     ival = 1 automatic
c          = another value -> user-defined
c
c     val  = user-defined parameter values
c            (only used for "ival" not equal to 1)
c
c


      if (ival(2).ne.1) pacto=val(2)

      if (ival(4).ne.1) vel=val(4)

      

c
c     Writes initial guess of parameters input by the user or
c     estimated from LC
c


      write (2,*) 
      write (2,*) 'Initial parameter estimates (initial values)'
      write (2,*) 
c
      write (2,*) 
      write (2,*) 


      write (2,*) 'impact parameter  (")    = ',pacto
      write (2,*) 'relative velocity ("/s)  = ',vel
      write (2,*) 

      aux=dsin(grarad*pacto/3600.d0)*distan
      auy=dsin(grarad*vel/3600.d0)*distan


      write (2,*) 'impact parameter (km)    = ',aux
      write (2,*) 'relative velocity (Km/s) = ',auy

      write (2,*) 
      write (2,34) ' Central instant (Julian Date) = ',tzero+djzero
 34   format(a33,f16.8)
      write (2,*) 


      aux=tzero

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      write (2,35) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0
 35   format(' Central instant (h,m,s,d,mo,yr) = ',2(i2.2,1x),f6.3,1x,
     ?i2.2,1x,i2.2,1x,i4)


      write (2,*) 
      write (2,*) 


c
c     Albedo ratio estimates
c

      aux=ralb*(r2/r1)**2


      if (ival(1).ne.1) then
      ralb=val(1)
      else
      ralb=aux
      endif

c



      write (2,*) 
      if (icod.eq.1) then
      write (2,*) 'Albedo ratio (occulting/occulted) = ',ralb
      endif
      write (2,*) 
      write (2,*) 




c
c     Non-linear LS, Marquardt Method with empirical (numerical)
c     derivatives of LC for the parameters
c


      nterms=ipar


      do i=1,nterms
      sigmaa(i)=0.d0
      enddo

      do j=1,nterms
      do i=1,nterms
      array(i,j)=0.d0
      enddo
      enddo


c
c     Initial parameters and respective actual units for fitting
c
c
c     param(1)= Albedo ratio (occulting/occulted)
c     param(2)= impact parameter (Km)
c     param(3)= central instant (MJD or JD - 2400000.5D0)
c     param(4)= relative velocity (Km/JD)
c
c


      param(1)=ralb
      param(2)=dsin(grarad*pacto/3600.d0)*distan
      param(3)=tzero
      param(4)=dsin(grarad*vel/3600.d0)*distan*86400.d0




c
c     Initial guess parameters input by the user
c


      do i=1,ipar
      if (ival(i).ne.1) param(i)=val(i)
      enddo

      if (ival(2).ne.1) then
      param(2)=dsin(grarad*param(2)/3600.d0)*distan
      endif

      if (ival(4).ne.1) then
      param(4)=dsin(grarad*param(4)/3600.d0)*distan*86400.d0
      endif

c
c     Parameter step sizes for empirical LC derivative computations
c

      parama(1)=dabs(parama(1)*param(1)*1.d-2)

      if (parama(1).eq.0.d0) parama(1)=0.1d0

      parama(2)=dabs(parama(2)*r1*1.d-2)

      parama(3)=dabs(parama(3)/86400.d0)

      parama(4)=dabs(parama(4)*param(4)*1.d-2)

c
c     LC fitting  !
c
 

      if (ifit.ne.1) go to 37


      call curfit (iiconv,iqua,r1,r2,nptos,cflux,fluxo,dj,nterms,
     ?icod,pre,fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,ru,rp,
     ?parama,param,chisqr,itira,Fl,jnum3,gamaf)



 37   continue

c


c
c     Stores fitted LC and standard deviation with respect to observed
c     normalized LC.
c
c     cursig = standard deviation in normilized flux ratio
c
c     Only non-eliminated LC points are computed
c
c     Also stores in "itira" the new outlier points to be eliminated in
c     the next external iteration loop
c
c


      xvam=0.d0
      xvas=0.d0
      n=0

c
c     Fills in fitted LC flux ratio for all points
c


      call funcao (iv,r1,r2,param(2),param(4),dj(1),param(3),icod,pre,
     ?param(1),flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru(1),rp(1),Fl,jnum3,gamaf)

      call funcao (iv,r1,r2,param(2),param(4),dj(nptos),param(3),icod,
     ?pre,param(1),flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),
     ?Dir2(nptos),Dir3(nptos),cosbeta(nptos),modVs1(nptos),
     ?modVs2(nptos),ru(nptos),rp(nptos),Fl,jnum3,gamaf)

      flmax=dmax1(flmax1,flmaxn)

 

      do i=1,nptos

      call funcao (iv,r1,r2,param(2),param(4),dj(i),param(3),icod,pre,
     ?param(1),fluxo(i),fase1(i),fase2(i),Dir1(i),Dir2(i),Dir3(i),
     ?cosbeta(i),modVs1(i),modVs2(i),ru(i),rp(i),Fl,jnum3,gamaf)

      fluxo(i)=fluxo(i)/flmax


      enddo

c

      if (ifit.ne.1) go to 60

c


      do i=1,nptos

      aux=fluxo(i)-cflux(i)

      if (itira(i).eq.0) then
      n=n+1
      xvam=xvam+aux
      xvas=xvas+aux**2
      endif

      if (dabs(aux).gt.corte) itira(i)=-1

      enddo


      call desvio (n,xvam,xvas)

      cursig=xvas

      npata=n


c
c     Computes (O-C) standard deviation (sigma) for LC before event
c

      xvam=0.d0
      xvas=0.d0
      n1=0

  

      do i=1,i1-1

      aux=fluxo(i)-cflux(i)

      if (itira(i).eq.0) then
      n1=n1+1
      xvam=xvam+aux
      xvas=xvas+aux**2
      endif

      enddo


      call desvio (n1,xvam,xvas)

      cursi1=xvas



c
c     Computes (O-C) standard deviation (sigma) for LC within event
c


      xvam=0.d0
      xvas=0.d0
      nm=0

  

      do i=i1,i2

      aux=fluxo(i)-cflux(i)

      if (itira(i).eq.0) then
      nm=nm+1
      xvam=xvam+aux
      xvas=xvas+aux**2
      endif

      enddo


      call desvio (nm,xvam,xvas)

      cursim=xvas



c
c     Computes (O-C) standard deviation (sigma) for LC after event
c


      xvam=0.d0
      xvas=0.d0
      n2=0

  

      do i=i2+1,nptos

      aux=fluxo(i)-cflux(i)

      if (itira(i).eq.0) then
      n2=n2+1
      xvam=xvam+aux
      xvas=xvas+aux**2
      endif

      enddo


      call desvio (n2,xvam,xvas)

      cursi2=xvas




c
c     Computes standard error for each LC point
c
c
c     efluxo - standard error of each LC point
c
c     curepm - average of all standard errors
c     cureps - standard deviation about this average
c



      xvam=0.d0
      xvas=0.d0


      n=0

      do i=1,nptos

      do m=1,nterms
      deltaa(m)=0.d0
      enddo

      call fderiv (nterms,iqua,r1,r2,i,dj,parama,param,nptos,icod,pre,
     ?fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,deriv,Fl,
     ?jnum3,gamaf)


      ll=0
      do 41 l=1,nterms
      if (iqua(l).ne.1) go to 41
      ll=ll+1
      kk=0
      do 40 k=1,nterms
      if (iqua(k).ne.1) go to 40 
      kk=kk+1
      deltaa(l)=deltaa(l)+array(ll,kk)*deriv(kk)
 40   continue
 41   continue

      kk=0
      do k=1,nterms
      if (iqua(k).eq.1) then
      kk=kk+1     
      efluxo(i)=efluxo(i)+deriv(kk)*deltaa(k)
      endif
      enddo

      efluxo(i)=cursig*dsqrt(efluxo(i))

      if (itira(i).le.0) then
      n=n+1
      xvam=xvam+efluxo(i)
      xvas=xvas+efluxo(i)**2
      endif

      enddo

c

      call desvio (n,xvam,xvas)

      curepm=xvam
      cureps=xvas


c
c     Marks new outlier LC points to be eliminated in the next external
c     iterative loop in case |O-C| is above threshold
c


      do i=1,nptos
      if (itira(i).lt.0) itira(i)=1
      enddo


c
c     Fitted parameters and respective errors
c

      ii=0
      do i=1,nterms
      if (iqua(i).eq.1) then
      ii=ii+1
      sigmaa(i)=dsqrt(array(ii,ii))
      endif
      enddo


      fundo=fundo
      efundo=fundo2


      ralb=param(1)
      if (iqua(1).eq.1) then
      eralb=cursig*sigmaa(1)
      else
      eralb=0.d0
      endif

      pacto=param(2)
      if (iqua(2).eq.1) then
      epacto=cursig*sigmaa(2)
      else
      epacto=0.d0
      endif

      tzero=param(3)+djzero
      if (iqua(3).eq.1) then
      etzero=cursig*sigmaa(3)
      else
      etzero=0.d0
      endif

      vel=param(4)
      if (iqua(4).eq.1) then
      evel=cursig*sigmaa(4)
      else
      evel=0.d0
      endif

c
c     Write final results
c



      write (2,*)
      write (2,*)
      write (2,*) 'Non-linear L.S. final solution of parameters:'  
      write (2,*)
      write (2,*)

c
c     Event beggining and end from the LC fit
c

      f1=fluxo(1)
      fn=fluxo(nptos)

      do i=1,nptos
      dif=dabs(fluxo(i)-f1)
      if (dif.gt.cursi1) go to 42
      enddo

 42   jj1=i

      do i=nptos,1,-1
      dif=dabs(fluxo(i)-fn)
      if (dif.gt.cursi2) go to 43
      enddo

 43   jj2=i


      aux=1.d14
      do i=1,nptos
      if (fluxo(i).lt.aux) then
      jm=i
      aux=fluxo(i)
      endif
      enddo

c

      dinif=dj(jj1)
      dfimf=dj(jj2)
      duraf=dabs(dfimf-dinif)*86400.d0

c


      write (2,*)
      write (2,*)
      write (2,*) 'Beggining, middle, end from fitted LC: '
      write (2,*) 

c

      aux=dinif

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=dinif+djzero

      write (2,10) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
      write (2,11) jj1,time(jj1)

      write (2,*) 

c

      aux=tzero-djzero

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=tzero+djzero

      write (2,12) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
      write (2,11) jm,time(jm)

      write (2,*) 

c

      aux=dfimf

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=dfimf+djzero

      write (2,13) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
      write (2,11) jj2,time(jj2)


      write (2,*) 

      write (2,44) duraf
 44   format(' Event duration (seconds) = ',f16.3)

      write (2,*) 
      write (2,*) 
      write (2,*) 


c

      write (2,*)
      write (2,*)'Normalized background + error         = ',fundo,efundo
      write (2,*)


      auxx=radgra*3600.d0*datan2(pacto,distan)
      auyy=radgra*3600.d0*datan2(epacto,distan)

      aux=radgra*3600.d0*datan2(vel,distan)/86400.d0
      auy=radgra*3600.d0*datan2(evel,distan)/86400.d0

      spacto=auxx
      svelo=aux


      write (2,*) 
      write (2,*) 'impact parameter  + error  (")        = ',auxx,auyy
      write (2,*) 
      write (2,*) 'relative velocity + error  ("/s)      = ',aux,auy
      write (2,*) 
      
      aux=vel/86400.d0
      auy=evel/86400.d0

      dvelo=aux


      write(2,*) 'impact parameter  + error  (km)       = ',pacto,epacto
      write(2,*) 
      write(2,*) 'relative velocity + error  (Km/s)     = ',aux,auy

      write (2,*) 
      write(2,47)' Central instant (Julian Date)         = ',tzero 
      write (2,*) 

      write(2,47)' Central instant error (Julian Date)   = ',etzero

      otzero=tzero

      stzero=etzero*86400.d0
      dtzero=stzero*dabs(aux)

      write(2,47)' Central instant error (seconds)       = ',stzero
      write(2,47)' Central instant error (kilometes)     = ',dtzero
      write (2,*) 

 47   format(a41,1x,f16.8)
      write (2,*) 


      aux=tzero-djzero

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=etzero*86400.d0

      write (2,50) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
 50   format(' Central instant (h,m,s,d,mo,yr) + error (s) = ',2(i2.2,
     ?1x),f6.3,1x,i2.2,1x,i2.2,1x,i4,4x,f7.3)


      write (2,*) 
      if (icod.eq.1) then
      write(2,*) 'Albedo ratio occulting/occulted + error = ',ralb,eralb
      endif
      write (2,*) 
      write (2,*) 


c
c     Statistics
c


      write (2,*) 
      write (2,*) 
      write (2,*) 
      write (2,*) 'sigma (O-C) in flux ratio           = ',cursig
      write (2,*) 
      write (2,*) 'Average standard error of curve fit = ',curepm
      write (2,*) 'Sigma about this average            = ',cureps
      write (2,*) 
      write (2,*) 'Number of fitted points             = ',npata
      write (2,*) 
      write (2,*) 

      np1=i1-1
      np2=nptos-i2
      npm=i2-i1+1

      write (2,*) 
      write (2,*) 'sigma (O-C) before event             = ',cursi1
      write (2,*) 'Total number of points for this part = ',np1
      write (2,*) 'Number of used points                = ',n1    
      write (2,*) 
      write (2,*) 
      write (2,*) 
      write (2,*) 'sigma (O-C) after  event             = ',cursi2
      write (2,*) 'Total number of points for this part = ',np2
      write (2,*) 'Number of used points                = ',n2
      write (2,*) 
      write (2,*) 
      write (2,*) 
      write (2,*) 'sigma (O-C) during event             = ',cursim
      write (2,*) 'Total number of points for this part = ',npm
      write (2,*) 'Number of used points                = ',nm    
      write (2,*) 
      write (2,*) 
      write (2,*) 
      write (2,*) 
      write (2,*) 'Table of non-L.S. fitted parameters correlations: '
      write (2,*) 
      write (2,*) 
      write (2,*) 

c

      label(1)=' albedos  '
      label(2)='   x0     '
      label(3)='   t0     '
      label(4)='   v0     '

      write (2,*) '                  albedos        x0            t0    
     ?        v0'
      write (2,*) 
      write (2,*) 


c

      do i=1,nterms
      do j=1,nterms
      xrray(i,j)=0.d0
      enddo
      enddo

c

      ii=0

      do 54 i=1,nterms

      if (iqua(i).ne.1) go to 54

      ii=ii+1
      jj=0
      
      do 53 j=1,nterms

      if (iqua(j).ne.1) go to 53
   
      jj=jj+1

      xrray(j,i)=array(ii,jj)/(sigmaa(i)*sigmaa(j))

 53   continue
 54   continue


      do i=1,nterms
      write (2,55) label(i),(xrray(i,j),j=1,nterms)
 55   format(a10,4(6x,f8.3))
      enddo

c

 60   continue

c


c
c     Computing relative distances of ocultator (2) with regard to
c     occulted (1) body. Reference is the occulted (1) body.
c
c     In the case of eclipses, (2) is the umbra figure as projected in the
c     sky plane of the observer and (1) is the eclipsed body.
c
c     Distances are in arcseconds in the sky plane.
c

      if (icod.eq.1) then

      do i=1,nptos

      x1=ra1(i)
      x2=ra2(i)

      y1=de1(i)
      y2=de2(i)

      d(i)=3600.d0*dsqrt(((x1-x2)*dcos(grarad*y1))**2+(y1-y2)**2)

      dx(i)=dsin(grarad*(x2-x1))*distan*dabs(dcos(grarad*y1))
      dy(i)=dsin(grarad*(y2-y1))*distan

      enddo

      else

      
      do i=1,nptos

      x1=ra1(i)
      x2=ura2(i)

      y1=de1(i)
      y2=ude2(i)

      d(i)=3600.d0*dsqrt(((x1-x2)*dcos(grarad*y1))**2+(y1-y2)**2)

      dx(i)=dsin(grarad*(x2-x1))*distan*dabs(dcos(grarad*y1))
      dy(i)=dsin(grarad*(y2-y1))*distan


      enddo


      endif


c
c     Determines impact parameter from ephemeris
c

      xxx=1.d14

      do i=1,nptos
      if (d(i).lt.xxx) then
      jm=i
      xxx=d(i)
      endif
      enddo

      ii1=jm-1
      ii2=jm+1


      igrau=2
      sig=0.d0

      do i=1,igrau+1
      coef(i)=0.d0
      enddo
 

      i=0
      do j=ii1,ii2
      i=i+1
      xest(i)=dj(j)-djmin
      xp(i)=d(j)
      enddo

      n=i

      call solfun (igrau,n,xest,xp,coef,sig)

      defmin=-coef(2)/(2.d0*coef(3))

      pacte=0.d0


      do k=1,igrau+1
      pacte=pacte+coef(k)*defmin**(k-1)
      enddo

      defmin=defmin+djmin



c
c     Estimates relative velocity from ephemeris  ("/s)
c




      vele=(dsqrt(d(jj2)**2-pacte**2)+dsqrt(d(jj1)**2-pacte**2))/
     ?(dj(jj2)-dj(jj1))


      vele=vele/86400.d0



c
c     Construction of theoretical LC from ephemeris
c


      param(1)=ralb
      param(2)=dsin(grarad*pacte/3600.d0)*distan
      param(3)=defmin
      param(4)=dsin(grarad*vele/3600.d0)*distan*86400.d0



      call funcao (iv,r1,r2,param(2),param(4),dj(1),param(3),icod,pre,
     ?param(1),flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),xxxxx,yyyyy,Fl,jnum3,gamaf)

      call funcao (iv,r1,r2,param(2),param(4),dj(nptos),param(3),icod,
     ?pre,param(1),flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),
     ?Dir2(nptos),Dir3(nptos),cosbeta(nptos),modVs1(nptos),
     ?modVs2(nptos),xxxxx,yyyyy,Fl,jnum3,gamaf)

      flmax=dmax1(flmax1,flmaxn)

 

      do i=1,nptos

      call funcao (iv,r1,r2,param(2),param(4),dj(i),param(3),icod,pre,
     ?param(1),flueph(i),fase1(i),fase2(i),Dir1(i),Dir2(i),Dir3(i),
     ?cosbeta(i),modVs1(i),modVs2(i),xxxxx,yyyyy,Fl,jnum3,gamaf)

      flueph(i)=flueph(i)/flmax

      enddo

      i=jm

      call funcao (iv,r1,r2,param(2),param(4),dj(i),param(3),icod,pre,
     ?param(1),flueph(i),fase1(i),fase2(i),Dir1(i),Dir2(i),Dir3(i),
     ?cosbeta(i),modVs1(i),modVs2(i),xxxxx,yyyyy,Fl,jnum3,gamaf)

      flueph(i)=flueph(i)/flmax


c



      write (2,*) 
      write (2,*) 
      write (2,*) 


      write (2,*)
      write (2,*)
      write (2,*) 'Ephemeris-based solution of parameters:'  
      write (2,*)
      write (2,*)


      write (2,61) tela
 61   format(' Ephemeris origin: ',a50)

      write (2,*)
      write (2,*)


c
c     Event beggining and end
c



      x=0.d0
      s=0.d0
      n=0

      ix1=nptos/10.d0
      ix2=nptos-ix1

      do i=1,ix1
      n=n+1
      x=x+flueph(i)
      s=s+flueph(i)**2
      enddo

      do i=ix2,nptos
      n=n+1
      x=x+flueph(i)
      s=s+flueph(i)**2
      enddo

      call desvio (n,x,s)


      s=7.d0*s

      fn=x

      do i=1,nptos
      dif=dabs(flueph(i)-fn)
      if (dif.gt.s) go to 62
      enddo

 62   jj1=i

      do i=nptos,1,-1
      dif=dabs(flueph(i)-fn)
      if (dif.gt.s) go to 63
      enddo

 63   jj2=i


c

      dinif=dj(jj1)
      dfimf=dj(jj2)
      duraf=dabs(dfimf-dinif)*86400.d0

c


      write (2,*)
      write (2,*)
      write (2,*) 'Beggining, middle, end from ephemeris: '
      write (2,*) 

c

      aux=dinif

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=dinif+djzero

      write (2,10) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
      write (2,11) jj1,time(jj1)

      write (2,*) 

c

      aux=defmin

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=defmin+djzero

      write (2,12) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
      write (2,11) jm,time(jm)

      write (2,*) 

c

      aux=dfimf

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0

      aux=dfimf+djzero

      write (2,13) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0,aux
      write (2,11) jj2,time(jj2)


      write (2,*) 

      write (2,44) duraf

      write (2,*) 
      write (2,*) 
      write (2,*) 


c


      write (2,*) 
      write (2,*) 'impact parameter   (")        = ',pacte
      write (2,*) 
      write (2,*) 'relative velocity  ("/s)      = ',vele
      write (2,*) 
      

      aux=dsin(grarad*pacte/3600.d0)*distan
      auy=dsin(grarad*vele/3600.d0)*distan


      write(2,*)  'impact parameter   (km)       = ',aux
      write(2,*) 
      write(2,*)  'relative velocity  (Km/s)     = ',auy


      tzero=defmin+djzero

      tzere=tzero


      write (2,*) 
      write(2,67)' Central instant (Julian Date) = ',tzero
 67   format(a33,1x,f16.8)
      write (2,*) 


      aux=tzero-djzero

      call iau_jd2cal (djzero,aux,iutan0,iutme0,iutdi0,fd,jjj)

      hora0=fd*24.d0
      iuth0=hora0
      iutm0=(hora0-iuth0)*60.d0
      sut0 =((hora0-iuth0)*60.d0-iutm0)*60.d0


      write (2,69) iuth0,iutm0,sut0,iutdi0,iutme0,iutan0
 69   format(' Central instant (h,m,s,d,mo,yr)     = ',2(i2.2,
     ?1x),f6.3,1x,i2.2,1x,i2.2,1x,i4)


c
c     Comparison between fitted LC and ephemeris LC.
c     (DX,DY) offsets between orbits in the sense
c     "observed minus ephemeris"
c

      xx=dx(jj2)-dx(jj1)
      yy=dy(jj2)-dy(jj1)

c
c     Computing inclination of relative orbit path
c

      teta=dabs(datan2(dabs(yy),dabs(xx)))

      ac=teta

      if (yy.ge.0.d0) then

      if (xx.lt.0.d0) ac=pi-teta

      else

      if (xx.ge.0.d0) then
      ac=2.d0*pi-teta
      else
      ac=pi+teta
      endif

      endif


c
c     Determining (DX,DY)
c

      dt=otzero-tzere

      dd=spacto-pacte

      dv=svelo-vele

c

      write (2,*)
      write (2,*)

      write (2,*)
      write (2,*)

      write (2,*)' Comparison between observation and ephemeris.'
      write (2,*)

      write (2,*)
      write (2,*)

      write(2,*)' Differences in the sense Observation minus Ephemeris.'
      write (2,*)
      write (2,*)

c

 75   format(a33,1x,f16.8)

      sdt=dt*86400.d0
      auxx=sdt*dabs(dvelo)

      write(2,75)' Central instant (seconds)     = ',sdt
      write(2,75)' Central instant (kilometers)  = ',auxx
      write (2,*) 

c

      auxx=dsin(grarad*dd/3600.d0)*distan

      write(2,75)' Impact parameter (")          = ',dd
      write(2,75)' Impact parameter (kilometers) = ',auxx
      write (2,*) 

c

      auxx=dsin(grarad*dv/3600.d0)*distan


      write(2,75)' Relative velocity ("/s)       = ',dv
      write(2,75)' Relative velocity (km/s)      = ',auxx
      write (2,*) 

c

      write (2,*)
      write (2,*)

      write(2,*)' (DX,DY) orbital offsets: Observation minus Ephemeris.'
      write (2,*)
      write (2,*)


      dxr=dd*dcos(ac)-(-vele*sdt)*dsin(ac)
      dyr=dd*dsin(ac)+(-vele*sdt)*dcos(ac)


      aux=dsin(grarad*dxr/3600.d0)*distan
      auy=dsin(grarad*dyr/3600.d0)*distan

      write(2,75)' Dacosd (")                    = ',dxr
      write(2,75)' Dd     (")                    = ',dyr
      write (2,*) 

      write(2,75)' Dacosd (kilometers)           = ',aux
      write(2,75)' Dd     (kilometers)           = ',auy
      write (2,*) 

      teta=ac*radgra

      write(2,75)' Relative path inclination (dg)= ',teta
      write (2,*) 


c
c     Solar phase angle, umbra and penumbra radius
c


      write (2,*)
      write (2,*)

      write (2,*)
      write (2,*)

      write (2,*)' Geometrical information:'
      write (2,*)

      write (2,*)
      write (2,*)

      write (2,80) fase1(jm)*radgra
 80   format(' Solar phase angle (degrees) = ',f16.11)


      write (2,*)
      write (2,*)


      if (icod.eq.1) then

      write (2,82) r2   
 82   format(' Occulting body radius (km) = ',f16.6)
      write (2,*)

      write (2,83) r1
 83   format(' Occulted  body radius (km) = ',f16.6)
      write (2,*)
      write (2,*)

      endif


      if (icod.eq.2) then

      write (2,84) r2   
 84   format(' Eclipsing body radius (km) = ',f16.6)
      write (2,*)

      write (2,85) r1
 85   format(' Eclipsed  body radius (km) = ',f16.6)
      write (2,*)
      write (2,*)

      write (2,86) xxxxx
 86   format(' Umbra radius (km) at eclipsed body plane    = ',f16.6)
      write (2,*)

      write (2,87) yyyyy
 87   format(' Penumbra radius (km) at eclipsed body plane = ',f16.6)
      write (2,*)
      write (2,*)

      endif



c
c     Restore Julian Dates for "dj"
c


      do i=1,nptos
      dj(i)=dj(i)+djzero
      enddo





      return
      end





c
c     Subroutine cal2JD
c
c
      SUBROUTINE iau_CAL2JD ( IY, IM, ID, DJM0, DJM, J )
*+
*  - - - - - - - - - - -
*   i a u _ C A L 2 J D
*  - - - - - - - - - - -
*
*  Gregorian Calendar to Julian Date.
*
*  This routine is part of the International Astronomical Union's
*  SOFA (Standards of Fundamental Astronomy) software collection.
*
*  Status:  support routine.
*
*  Given:
*     IY,IM,ID    i     year, month, day in Gregorian calendar (Note 1)
*
*  Returned:
*     DJM0        d     MJD zero-point: always 2400000.5
*     DJM         d     Modified Julian Date for 0 hrs
*     J           i     status:
*                           0 = OK
*                          -1 = bad year   (Note 3: JD not computed)
*                          -2 = bad month  (JD not computed)
*                          -3 = bad day    (JD computed)
*
*  Notes:
*
*  1) The algorithm used is valid from -4800 March 1, but this
*     implementation rejects dates before -4799 January 1.
*
*  2) The Julian Date is returned in two pieces, in the usual SOFA
*     manner, which is designed to preserve time resolution.  The
*     Julian Date is available as a single number by adding DJM0 and
*     DJM.
*
*  3) In early eras the conversion is from the "Proleptic Gregorian
*     Calendar";  no account is taken of the date(s) of adoption of
*     the Gregorian Calendar, nor is the AD/BC numbering convention
*     observed.
*
*  Reference:
*
*     Explanatory Supplement to the Astronomical Almanac,
*     P.Kenneth Seidelmann (ed), University Science Books (1992),
*     Section 12.92 (p604).
*
*  This revision:  2000 December 15
*
*  Copyright (C) 2001 IAU SOFA Review Board.  See notes at end.
*
*-----------------------------------------------------------------------

      IMPLICIT NONE

      INTEGER IY, IM, ID
      DOUBLE PRECISION DJM0, DJM
      INTEGER J, MY, IYPMY

*  Earliest year allowed (4800BC)
      INTEGER IYMIN
      PARAMETER ( IYMIN = -4799 )

*  Month lengths in days
      INTEGER MTAB(12)
      DATA MTAB / 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 /

* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

*  Preset status.
      J = 0

*  Validate year.
      IF ( IY.LT.IYMIN ) THEN
         J = -1
      ELSE

*     Validate month.
         IF ( IM.GE.1 .AND. IM.LE.12 ) THEN

*        Allow for leap year.
            IF ( MOD(IY,4) .EQ. 0 ) THEN
               MTAB(2) = 29
            ELSE
               MTAB(2) = 28
            END IF
            IF ( MOD(IY,100).EQ.0 .AND. MOD(IY,400).NE.0 ) MTAB(2) = 28

*        Validate day.
            IF ( ID.LT.1 .OR. ID.GT.MTAB(IM) ) J = -3

*        Result.
            MY = ( IM - 14 ) / 12
            IYPMY = IY + MY
            DJM0 = 2400000.5D0
            DJM = DBLE( ( 1461 * ( IYPMY + 4800 ) ) / 4
     :                + (  367 * ( IM-2 - 12*MY ) ) / 12
     :                - (    3 * ( ( IYPMY + 4900 ) / 100 ) ) / 4
     :                + ID - 2432076)

*        Bad month
         ELSE
            J = -2
         END IF
      END IF

*  Finished.

*+----------------------------------------------------------------------
*
*  Copyright (C) 2001
*  Standards Of Fundamental Astronomy Review Board
*  of the International Astronomical Union.
*
*  =====================
*  SOFA Software License
*  =====================
*
*  NOTICE TO USER:
*
*  BY USING THIS SOFTWARE YOU ACCEPT THE FOLLOWING TERMS AND CONDITIONS
*  WHICH APPLY TO ITS USE.
*
*  1. The Software is owned by the IAU SOFA Review Board ("the Board").
*
*  2. The Software is made available free of charge for use by:
*
*     a) private individuals for non-profit research; and
*
*     b) non-profit educational, academic and research institutions.
*
*  3. Commercial use of the Software is specifically excluded from the
*     terms and conditions of this license.  Commercial use of the
*     Software is subject to the prior written agreement of the Board on
*     terms to be agreed.
*
*  4. The provision of any version of the Software under the terms and
*     conditions specified herein does not imply that future versions
*     will also be made available under the same terms and conditions.
*
*  5. The user may modify the Software for his/her own purposes.  The
*     user may distribute the modified software provided that the Board
*     is informed and that a copy of the modified software is made
*     available to the Board on request.  All modifications made by the
*     user shall be clearly identified to show how the modified software
*     differs from the original Software, and the name(s) of the
*     affected routine(s) shall be changed.  The original SOFA Software
*     License text must be present.
*
*  6. In any published work produced by the user and which includes
*     results achieved by using the Software, the user shall acknowledge
*     that the Software was used in producing the information contained
*     in such publication.
*
*  7. The user may incorporate or embed the Software into other software
*     products which he/she may then give away free of charge but not
*     sell provided the user makes due acknowledgement of the use which
*     he/she has made of the Software in creating such software
*     products.  Any redistribution of the Software in this way shall be
*     made under the same terms and conditions under which the user
*     received it from the SOFA Center.
*
*  8. The user shall not cause the Software to be brought into
*     disrepute, either by misuse, or use for inappropriate tasks, or by
*     inappropriate modification.
*
*  9. The Software is provided to the user "as is" and the Board makes
*     no warranty as to its use or performance.   The Board does not and
*     cannot warrant the performance or results which the user may
*     obtain by using the Software.  The Board makes no warranties,
*     express or implied, as to non-infringement of third party rights,
*     merchantability, or fitness for any particular purpose.  In no
*     event will the Board be liable to the user for any consequential,
*     incidental, or special damages, including any lost profits or lost
*     savings, even if a Board representative has been advised of such
*     damages, or for any claim by any third party.
*
*  Correspondence concerning SOFA software should be addressed as
*  follows:
*
*     Internet email: sofa@rl.ac.uk
*     Postal address: IAU SOFA Center
*                     Rutherford Appleton Laboratory
*                     Chilton, Didcot, Oxon OX11 0QX
*                     United Kingdom
*
*
*-----------------------------------------------------------------------

      return

      END




c
c     Subroutine iau_jd2cal
c
c


      SUBROUTINE iau_jd2cal ( DJ1, DJ2, IY, IM, ID, FD, J )
*+
*  - - - - - - - - - - -
*   i a u _ J D 2 C A L
*  - - - - - - - - - - -
*
*  Julian Date to Gregorian year, month, day, and fraction of a day.
*
*  This routine is part of the International Astronomical Union's
*  SOFA (Standards of Fundamental Astronomy) software collection.
*
*  Status:  support routine.
*
*  Given:
*     DJ1,DJ2     d     Julian Date (Notes 1, 2)
*
*  Returned:
*     IY          i     year
*     IM          i     month
*     ID          i     day
*     FD          d     fraction of day
*     J           i     status:
*                           0 = OK
*                          -1 = unacceptable date (Note 3)
*
*  Notes:
*
*  1) The earliest valid date is -68569.5 (-4900 March 1).  The
*     largest value accepted is 10^9.
*
*  2) The Julian Date is apportioned in any convenient way between
*     the arguments DJ1 and DJ2.  For example, JD=2450123.7 could
*     be expressed in any of these ways, among others:
*
*             DJ1            DJ2
*
*         2450123.7D0        0D0        (JD method)
*          2451545D0      -1421.3D0     (J2000 method)
*         2400000.5D0     50123.2D0     (MJD method)
*         2450123.5D0       0.2D0       (date & time method)
*
*  3) In early eras the conversion is from the "Proleptic Gregorian
*     Calendar";  no account is taken of the date(s) of adoption of
*     the Gregorian Calendar, nor is the AD/BC numbering convention
*     observed.
*
*  Reference:
*
*     Explanatory Supplement to the Astronomical Almanac,
*     P.Kenneth Seidelmann (ed), University Science Books (1992),
*     Section 12.92 (p604).
*
*  This revision:  2000 December 19
*
*  Copyright (C) 2001 IAU SOFA Review Board.  See notes at end.
*
*-----------------------------------------------------------------------

      IMPLICIT NONE

      DOUBLE PRECISION DJ1, DJ2
      INTEGER IY, IM, ID
      DOUBLE PRECISION FD
      INTEGER J

*  Minimum and maximum allowed JD
      DOUBLE PRECISION DJMIN, DJMAX
      PARAMETER ( DJMIN = -68569.5D0, DJMAX = 1D9 )

      INTEGER JD, L, N, I
      DOUBLE PRECISION DJ, D1, D2, F1, F2, F, D

* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

*  Check if date is acceptable.
      DJ = DJ1 + DJ2
      IF ( DJ.LT.DJMIN .OR. DJ.GT.DJMAX ) THEN
         J = -1
      ELSE
         J = 0

*     Copy the date, big then small, and re-align to midnight.
         IF ( DJ1 .GE. DJ2 ) THEN
            D1 = DJ1
            D2 = DJ2
         ELSE
            D1 = DJ2
            D2 = DJ1
         END IF
         D2 = D2 - 0.5D0

*     Separate day and fraction.
         F1 = MOD(D1,1D0)
         F2 = MOD(D2,1D0)
         F = MOD(F1+F2,1D0)
         IF ( F .LT. 0D0 ) F = F+1D0
         D = ANINT(D1-F1) + ANINT(D2-F2) + ANINT(F1+F2-F)
         JD = NINT(D) + 1

*     Express day in Gregorian calendar.
         L = JD + 68569
         N = ( 4*L ) / 146097
         L = L - ( 146097*N + 3 ) / 4
         I = ( 4000 * (L+1) ) / 1461001
         L = L - ( 1461*I ) / 4 + 31
         J = ( 80*L ) / 2447
         ID = L - ( 2447*J ) / 80
         L = J / 11
         IM = J + 2 - 12*L
         IY = 100 * ( N-49 ) + I + L

         FD = F
         J = 0
      END IF

*  Finished.

*+----------------------------------------------------------------------
*
*  Copyright (C) 2001
*  Standards Of Fundamental Astronomy Review Board
*  of the International Astronomical Union.
*
*  =====================
*  SOFA Software License
*  =====================
*
*  NOTICE TO USER:
*
*  BY USING THIS SOFTWARE YOU ACCEPT THE FOLLOWING TERMS AND CONDITIONS
*  WHICH APPLY TO ITS USE.
*
*  1. The Software is owned by the IAU SOFA Review Board ("the Board").
*
*  2. The Software is made available free of charge for use by:
*
*     a) private individuals for non-profit research; and
*
*     b) non-profit educational, academic and research institutions.
*
*  3. Commercial use of the Software is specifically excluded from the
*     terms and conditions of this license.  Commercial use of the
*     Software is subject to the prior written agreement of the Board on
*     terms to be agreed.
*
*  4. The provision of any version of the Software under the terms and
*     conditions specified herein does not imply that future versions
*     will also be made available under the same terms and conditions.
*
*  5. The user may modify the Software for his/her own purposes.  The
*     user may distribute the modified software provided that the Board
*     is informed and that a copy of the modified software is made
*     available to the Board on request.  All modifications made by the
*     user shall be clearly identified to show how the modified software
*     differs from the original Software, and the name(s) of the
*     affected routine(s) shall be changed.  The original SOFA Software
*     License text must be present.
*
*  6. In any published work produced by the user and which includes
*     results achieved by using the Software, the user shall acknowledge
*     that the Software was used in producing the information contained
*     in such publication.
*
*  7. The user may incorporate or embed the Software into other software
*     products which he/she may then give away free of charge but not
*     sell provided the user makes due acknowledgement of the use which
*     he/she has made of the Software in creating such software
*     products.  Any redistribution of the Software in this way shall be
*     made under the same terms and conditions under which the user
*     received it from the SOFA Center.
*
*  8. The user shall not cause the Software to be brought into
*     disrepute, either by misuse, or use for inappropriate tasks, or by
*     inappropriate modification.
*
*  9. The Software is provided to the user "as is" and the Board makes
*     no warranty as to its use or performance.   The Board does not and
*     cannot warrant the performance or results which the user may
*     obtain by using the Software.  The Board makes no warranties,
*     express or implied, as to non-infringement of third party rights,
*     merchantability, or fitness for any particular purpose.  In no
*     event will the Board be liable to the user for any consequential,
*     incidental, or special damages, including any lost profits or lost
*     savings, even if a Board representative has been advised of such
*     damages, or for any claim by any third party.
*
*  Correspondence concerning SOFA software should be addressed as
*  follows:
*
*     Internet email: sofa@rl.ac.uk
*     Postal address: IAU SOFA Center
*                     Rutherford Appleton Laboratory
*                     Chilton, Didcot, Oxon OX11 0QX
*                     United Kingdom
*
*
*-----------------------------------------------------------------------


      return
      END







C
C
C     Subroutine ordem
C
C
C
C     Purpose
C
C       Orders data vectors in crescent value order.
C
C
C     Use
C
C     SUBROUTINE ORDEM (N,IOR,VAL)
C
C
C     Description of parameters
C
C       N      - number of points to be ordered
C       indx   - increasing order numbering of array "arr"
C       arr    - data array itself, NOT ORDERED
C
C
C     Subroutines and subprograms required
C
C
C
C     Comments
C
C
C

      SUBROUTINE ordem(n,indx,arr)
      IMPLICIT REAL*8 (A-H,O-Z)

      INTEGER n,indx(n),M,NSTACK
      REAL*8 arr(n)
      PARAMETER (M=7,NSTACK=50)
      INTEGER i,indxt,ir,itemp,j,jstack,k,l,istack(NSTACK)
      REAL*8 a
      do 11 j=1,n
        indx(j)=j
11    continue
      jstack=0
      l=1
      ir=n
1     if(ir-l.lt.M)then
        do 13 j=l+1,ir
          indxt=indx(j)
          a=arr(indxt)
          do 12 i=j-1,1,-1
            if(arr(indx(i)).le.a)goto 2
            indx(i+1)=indx(i)
12        continue
          i=0
2         indx(i+1)=indxt
13      continue
        if(jstack.eq.0)return
        ir=istack(jstack)
        l=istack(jstack-1)
        jstack=jstack-2
      else
        k=(l+ir)/2
        itemp=indx(k)
        indx(k)=indx(l+1)
        indx(l+1)=itemp
        if(arr(indx(l+1)).gt.arr(indx(ir)))then
          itemp=indx(l+1)
          indx(l+1)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l)).gt.arr(indx(ir)))then
          itemp=indx(l)
          indx(l)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l+1)).gt.arr(indx(l)))then
          itemp=indx(l+1)
          indx(l+1)=indx(l)
          indx(l)=itemp
        endif
        i=l+1
        j=ir
        indxt=indx(l)
        a=arr(indxt)
3       continue
          i=i+1
        if(arr(indx(i)).lt.a)goto 3
4       continue
          j=j-1
        if(arr(indx(j)).gt.a)goto 4
        if(j.lt.i)goto 5
        itemp=indx(i)
        indx(i)=indx(j)
        indx(j)=itemp
        goto 3
5       indx(l)=indx(j)
        indx(j)=indxt
        jstack=jstack+2
c       if(jstack.gt.NSTACK)pause 'NSTACK too small in ordem'
        if(ir-i+1.ge.j-l)then
          istack(jstack)=ir
          istack(jstack-1)=i
          ir=j-1
        else
          istack(jstack)=j-1
          istack(jstack-1)=l
          l=i
        endif
      endif
      goto 1

      return
      END






c
c     Subroutine solfun
c
c
c     Mono-variated polynomial fit of nth-degree. 
c
c
c     Last modified:  M. Assafin    01/Nov/2010
c
c
c

      subroutine solfun (ngrau,n,xest,xp,coef,sig)


      implicit real *8 (a-h,o-z)
      dimension coef(21),alpha(21,21),array(21,21),beta(21),term(21)

      dimension xest(100000),xp(100000)

      common /a7/array
      common/a14/ierro


C
C     Initializing data
C

      pi=3.141592653589793d0
      grarad=pi/180.d0
      radgra=180.d0/pi
      det  =1.d0
      ierro=0


      ipmax=100000
c

      sig=0.d0


c
c     Compute no. of terms of polynomial model
c

      nterms=ngrau+1

C
C     Checks No. of points to fit .vs. coefficients to fit
C


      if (n.lt.nterms) then
      ierro=1
      return
      endif

c
      do 9 i=1,nterms
      beta(i) =0.d0
      coef(i) =0.d0
      term(i) =0.d0
      do 5 j=1,nterms
      alpha(i,j)=0.d0
      array(i,j)=0.d0
 5    continue
 9    continue


C
C     Condition equation
C


      do 10 i=1,n
      x=xest(i)
      xg=xp(i)

C
C     Computs coefficient terms for  AtB
C

      do k=1,nterms
      term(k)=x**(k-1)
      enddo

      do l=1,nterms
      beta(l)=beta(l)+xg*term(l)
      do k=l,nterms
      alpha(l,k)=alpha(l,k)+term(k)*term(l)
      enddo
      enddo   

   10 continue

c
c     Fills symetric inferior triangular matrix for AtA
c


      do l=1,nterms
      do k=l,nterms
      alpha(k,l)=alpha(l,k)
      enddo
      enddo

c
c     Fills ARRAY=AtA for inversion (elements normalized by diagonal)
c


C
      do l=1,nterms
      do k=1,nterms
      array(l,k)=alpha(l,k)/dsqrt(alpha(l,l)*alpha(k,k))
      enddo
      enddo

C
C     Inverting AtA
C



      call matinv (nterms,det)
      if (ierro.eq.1) return

C
C     Computing polynomial coefficients
C

      do l=1,nterms
      do k=1,nterms
      array(l,k)=array(l,k)/dsqrt(alpha(k,k)*alpha(l,l))
      enddo
      enddo

      do l=1,nterms
      do k=1,nterms
      coef(l)=coef(l)+array(l,k)*beta(k)
      enddo
      enddo


c
c     Computing residuals over used points
c


      resm=0.d0
      res2=0.d0
      nn=0

      do 160 i=1,n

      nn=nn+1

      x=xest(i)
      xg=xp(i)


      pol=0.d0
      do k=1,nterms
      pol=pol+coef(k)*x**(k-1)
      enddo

      res=pol-xg

      resm=resm+res
      res2=res2+res**2


  160 continue

C
C     Computes average and standard deviation of (O-C)s
C

      call desvio (nn,resm,res2)

      sig=res2

c

      return
      end


C
C     SUBROUTINE MATINV
C
C     PURPOSE
C       INVERT A SYMMETRIC MATRIX AND CALCULATE ITS DETERMINANT
C
C     USAGE
C       CALL MATINV ( NORDER, DET)
C
C     DESCRIPTION OF PARAMETERS
C       ARRAY  - INPUT MATRIX WICH IS REPLACED BY ITS INVERSE
C       NORDER - DEGREE OF MATRIX (ORDER OF DETERMINANT)
C       DET    - DETERMINANT OF INPUT MATRIX
C
C     SUBROUTINES AND FUNCTION SUBPROGRAMS REQUIRED
C       NONE
C
C     MODIFICATIONS FOR FORTRAN II
C       OMIT DOUBLE PRECISION SPECIFICATIONS
C       CHANGE DABS TO ABSF IN STATEMENT 23
C
C     COMMENTS
C       DIMENSION STATEMANTS VALID FOR NORDER UP TO 10
C
      SUBROUTINE MATINV (NORDER, DET)
      IMPLICIT REAL *8 (A-H,O-Z)
      DIMENSION ARRAY (21,21), IK(21), JK(21)
      COMMON /A7/ARRAY
      COMMON /A14/IERRO
C
      DET = 1.D0
      DO 100 K=1, NORDER
C
C        FIND LARGEST ELEMENT ARRAY(I,J) IN REST OF MATRIX
C
      AMAX= 0.D0
   21 DO 30 I=K, NORDER
      DO 30 J=K, NORDER
      IF (DABS(AMAX) - DABS(ARRAY(I,J))) 24, 24, 30
   24 AMAX = ARRAY(I,J)
      IK(K) = I
      JK(K) = J
   30 CONTINUE
C
C        INTERCHANGE ROWS AND COLUMNS TO PUT AMAX IN ARRAY(K,K)
C
      IF (AMAX) 41, 32, 41
   32 DET = 0.D0
      GO TO 140
   41 I = IK(K)
      IF (I-K) 21, 51, 43
   43 DO 50 J=1, NORDER
      SAVE = ARRAY(K,J)
      ARRAY(K,J) = ARRAY(I,J)
   50 ARRAY(I,J) = -SAVE
   51 J = JK(K)
      IF (J-K) 21, 61, 53
   53 DO 60 I=1, NORDER
      SAVE = ARRAY(I,K)
      ARRAY (I,K) = ARRAY(I,J)
   60 ARRAY (I,J) = -SAVE
C
C        ACCUMULATE ELEMENTS OF INVERSE MATRIX
C
   61 DO 70 I=1, NORDER
      IF (I-K) 63, 70, 63
   63 IF (AMAX.EQ.0.D0) THEN
      IERRO=1
      RETURN
      ENDIF
      ARRAY(I,K) = -ARRAY(I,K) / AMAX
   70 CONTINUE
      DO 80 I=1, NORDER
      DO 80 J=1, NORDER
      IF (I-K) 74, 80, 74
   74 IF (J-K) 75, 80, 75
   75 ARRAY(I,J) = ARRAY(I,J) + ARRAY(I,K)*ARRAY(K,J)
   80 CONTINUE
      DO 90 J=1, NORDER
      IF (J-K) 83, 90, 83
   83 IF (AMAX.EQ.0.D0) THEN
      IERRO=1
      RETURN
      ENDIF
      ARRAY(K,J) = ARRAY(K,J) / AMAX
   90 CONTINUE
      IF (AMAX.EQ.0.D0) THEN
      IERRO=1
      RETURN
      ENDIF
      ARRAY(K,K) = 1.D0 / AMAX
  100 DET = DET * AMAX
C
C        RESTORE ORDERING OF MATRIX
C
      DO 130 L=1, NORDER
      K = NORDER - L + 1
      J = IK(K)
      IF (J-K) 111, 111, 105
  105 DO 110 I=1, NORDER
      SAVE = ARRAY(I,K)
      ARRAY(I,K) = -ARRAY(I,J)
  110 ARRAY(I,J) = SAVE
  111 I = JK(K)
      IF (I-K) 130, 130, 113
  113 DO 120 J=1, NORDER
      SAVE = ARRAY(K,J)
      ARRAY(K,J) = -ARRAY(I,J)
  120 ARRAY(I,J) = SAVE
  130 CONTINUE
  140 CONTINUE
      RETURN
      END



c
c
c
c     Subroutine curfit
c
c     Purpose
c
c     Non-linear Least-Squares (LS) fit to LC by the use of numerical model.
c
c     In this version, there is no analytical function being fitted. Instead,
c     the "function" is represented by values generated from a numerical
c     model. This numerical model does depend upon parameters, which are
c     indeed fitted here by non-linear Least-Squares, similarly to a non-linear
c     LS Marquardt Method. In particular, the derivatives of this numerical
c     function are also empirically (numerically) evaluated. Error estimates
c     for parameters, correlations, as well as everything else are computed
c     as much in the same way as in the usual Marquardt Method. Subroutines
c     are adaptations to those furnished in Bevington's "Data Reduction and
c     Error Analysis for the Physical Sciences" (1969).
c
c
c     Description of variables:
c
c
c       pre    - spatial resolution of LC numerical model (km)
c
c       icod   - key:
c                01: occultation model
c                02: eclipse model
c
c       iqua   - key: which parameters are to be fitted ?
c                1 : fit
c                0 : do not fit 
c
c       r1     - occultator radius (arcsec)
c       r2     - occulted radius   (arcsec)
c
c       iv     - number of points furnished to computing numerical model
c                (default = 1 point; evaluates each observation at a time)
c       pre    - scale factor km/pixel (surface resolution of numerical model)
c       fluxo  - fitted flux ratio from numerical model
c	fase1  -  vector with phase angles for occulted/eclipsed satellite 1 for
c                 each observation
c	fase2  -  vector with phase angles for occulting/eclipsing satellite 2 for
c                 each observation
c	Dir1   -  vector with inclination angles of line containing semi-ellipse focii
c                 of occulted/eclipsed satellite 1
c	Dir2   -  vector with inclination angles of line containing semi-ellipse focii
c                 of occulting satellite 2
c	Dir3   -  vector with inclination angles of line containing semi-ellipse focii
c                 of eclipsing shadow
c	cosbeta - vector containing angles between satellite heliocentric vectors for
c                  computing distances between
c                  eclipsed satellite and Sun
c       modVs1 - distance from occulted/eclipsed satellite 1 to Sun
c       modVs2 - distance from occulting/eclipseing satellite 2 to Sun
c
c       nptos  - number of points for fit  
c       nterms - number of parameters to fit    
c       a      - vector of parameters
c                a(1) = albedo ratio occultator/occulted (eclipsed/eclipsed)
c                a(2) = impact parameter (arcsec)
c                a(3) = central instant (DJ - 2400000.5D0)
c                a(4) = relative velocity (arcsec/dj)
c
c       deltaa - parameter steps for empirical derivative computations
c
c       sigmaa - error vector of "a" parameters
c       flamda - diagonalization factor of inverted matrix in Marquardt
c                Method gradient search
c       chisqr - chi-square of fit
c
c
c     Subroutines and functions required:
c
c          funcao (iv,r1,r2,a(2),a(4),dj(i),a(3),icod,pre,a(1),
c                  flux,fase1(i),fase2(i),Dir1(i),Dir2(i),Dir3(i),
c                  cosbeta(i),modVs1(i),modVs2(i),ru(i),rp(i))
c
c
c          numerical model with flux ratio values
c
c
c       qiquad (nptos,cflux,free,a,itira,fluxo)
c
c          chi-square of fit
c
c
c       fderiv (nterms,iqua,r1,r2,ii,dj,deltaa,a,nptos,icod,pre,fase1,fase2,
c               Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,deriv)
c
c          derivatives (empirically evaluated) of numerical model as a
c          function of parameters
c
c
c       matinv (nterms, det)
c
c          inverts simetric matrix of "nterms" degree and computes its
c          determinant
c
c
c     Comments:
c
c       Number of terms = 4 LC parameters (no fitted LC background here)
c
c
c
c      Last modification:  M. Assafin   19/Nov/2010
c       
c
c

      subroutine curfit (iconv,iqua,r1,r2,nptos,cflux,fluxo,dj,nterms,
     ?icod,pre,fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,
     ?ru,rp,deltaa,a,chisqr,itira,Fl,jnum3,gamaf)



      implicit real *8 (a-h,o-z)

      real*8 modVs1(100000),modVs2(100000)

      real*8 Fl(100000,2)

      real*8 gamaf

      integer*4 jnum3

      integer*8 iv,icod

      dimension deltaa(4),a(4),b(4),alpha(21,21),beta(21),deriv(4),
     ?array(21,21),iqua(4)

      dimension cflux(100000),dj(100000),itira(100000)

      dimension fase1(100000),fase2(100000),Dir1(100000),Dir2(100000),
     ?Dir3(100000),cosbeta(100000),fluxo(100000),ru(100000),rp(100000)


      common /a7/array
      common /a14/ierro

c



      ierro=0
      det=1.d0
      icont=0
      jconv=1
c

      iv=1
c
      write (*,90) jconv

      kcont=0
      do i=1,nterms
      if (iqua(i).eq.1) kcont=kcont+1
      enddo

 10   continue

      do i=1,nterms
      b(i)=0.d0
      beta(i)=0.d0
      do j=1,nterms
      array(i,j)=0.d0
      alpha(i,j)=0.d0
      enddo
      enddo



c 
c     Fills in alpha and beta vectors
c

      chisqr = 0.d0


c
c     Finds maximum of LC model for background normalization
c

      call funcao (iv,r1,r2,a(2),a(4),dj(1),a(3),icod,pre,a(1),
     ?flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru(1),rp(1),Fl,jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      call funcao (iv,r1,r2,a(2),a(4),dj(nptos),a(3),icod,pre,a(1),
     ?flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),Dir2(nptos),
     ?Dir3(nptos),cosbeta(nptos),modVs1(nptos),modVs2(nptos),ru(nptos),
     ?rp(nptos),Fl,jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      flmax=dmax1(flmax1,flmaxn)

c

      do 150 i=1,nptos
      if (itira(i).ne.0) go to 150

      call fderiv (nterms,iqua,r1,r2,i,dj,deltaa,a,nptos,icod,pre,
     ?fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,deriv,Fl,
     ?jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      icont=icont+1


      call funcao (iv,r1,r2,a(2),a(4),dj(i),a(3),icod,pre,a(1),fluxo(i),
     ?fase1(i),fase2(i),Dir1(i),Dir2(i),Dir3(i),cosbeta(i),modVs1(i),
     ?modVs2(i),ru(i),rp(i),Fl,jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      fluxo(i)=fluxo(i)/flmax


      jj=0
      do 147 j=1,nterms

      if (iqua(j).ne.1) go to 147

      jj=jj+1

      beta(jj)=beta(jj)+(cflux(i)-fluxo(i))*deriv(jj)

      kk=0
      do 146 k=1,j
      if (iqua(k).ne.1) go to 146
      kk=kk+1
      alpha(jj,kk)=alpha(jj,kk)+deriv(jj)*deriv(kk)
  146 continue  

  147 continue

  150 continue


      jterms=jj


c
c     Degrees of freedom
c

      FREE=icont-kcont

c

      if (free.le.0.d0) go to 107

c
c     Fills in the other diagonal side of the symetric matrix
c

      jj=0
      DO 55 j=1,nterms
      if (iqua(j).ne.1) go to 55
      jj=jj+1
      kk=0
      DO 54 k=1,j
      if (iqua(k).ne.1) go to 54
      kk=kk+1
      alpha(kk,jj)=alpha(jj,kk)
 54   continue
 55   continue



c
c     Computes chi-square of the first iteration
c


      chisq1=qiquad(nptos,cflux,free,itira,fluxo)


c
      if (ierro.eq.1) go to 107

c
c				 
c     Inverts curvature matrix to obtain new parameters
c

 71   continue

      jj=0

      do 74 j=1,nterms
      if (iqua(j).ne.1) go to 74
      jj=jj+1
      kk=0
      do 73 k=1,nterms
      if (iqua(k).ne.1) go to 73
      kk=kk+1
      aux =alpha(jj,jj)*alpha(kk,kk)
c     if (aux.lt.0.d0) go to 107
      array(jj,kk)=alpha(jj,kk)/dsqrt(aux)
 73   continue
c     array(jj,jj)=1.d0+flamda
 74   continue

      jterms=jj


      call matinv (jterms,det)


c

      if (ierro.eq.1) go to 107

c

      jj=0

      do 84 j=1,nterms
      b(j)=a(j)
      if (iqua(j).ne.1) go to 84
      jj=jj+1
      kk=0
      do 83 k=1,nterms
      if (iqua(k).ne.1) go to 83
      kk=kk+1
      aux=alpha(jj,jj)*alpha(kk,kk)
c     if (aux.lt.0.d0) go to 107
      b(j)=b(j)+beta(kk)*array(jj,kk)/dsqrt(aux)
 83   continue
 84   continue


c
c     Evaluates new fitted LC for new parameters "b"
c



      call funcao (iv,r1,r2,b(2),b(4),dj(1),b(3),icod,pre,b(1),
     ?flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru(1),rp(1),Fl,jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      call funcao (iv,r1,r2,b(2),b(4),dj(nptos),b(3),icod,pre,b(1),
     ?flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),Dir2(nptos),
     ?Dir3(nptos),cosbeta(nptos),modVs1(nptos),modVs2(nptos),ru(nptos),
     ?rp(nptos),Fl,jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      flmax=dmax1(flmax1,flmaxn)


      do i=1,nptos

      call funcao (iv,r1,r2,b(2),b(4),dj(i),b(3),icod,pre,b(1),fluxo(i),
     ?fase1(i),fase2(i),Dir1(i),Dir2(i),Dir3(i),cosbeta(i),modVs1(i),
     ?modVs2(i),ru(i),rp(i),Fl,jnum3,gamaf)

c     if (ierro.eq.1) go to 107

      fluxo(i)=fluxo(i)/flmax

      enddo



c
c     New chi-square
c

      chisqr = qiquad(nptos,cflux,free,itira,fluxo)

c
      write (*,*)
      write (*,*) 'Chi-square before and after linear LS iteration = ',
     ?chisq1,chisqr
      write (*,*)


c

      if (ierro.eq.1) go to 107


c
c     Hits maximum number of internal LS iterations
c



      jconv=jconv+1


      if (jconv.gt.iconv) then
      jconv=iconv
      go to 101
      endif

      write (*,90) jconv
 90   format(1x,'Internal iteration No. = ',i8)

c
c     Stores new parameter solution and re-starts proccess
c


      do i=1,nterms
      a(i)=b(i)
      enddo      

      go to 10



C
C     Stores final parameters, errors and correlations
C

 101  continue



      ii=0

      do 103 i=1,nterms
      if (iqua(i).ne.1) go to 103
      a(i)=b(i)
      ii=ii+1
      jj=0
      do 102 j=1,nterms
      if (iqua(j).ne.1) go to 102
      jj=jj+1
      aux=alpha(jj,jj)*alpha(ii,ii)
c     if (aux.lt.0.d0) go to 107
      array(ii,jj)=array(ii,jj)/dsqrt(aux)
  102 continue
  103 continue


c

      go to 110

c  

 107  continue

      chisqr = -1.d0
      ierro=1

c

  110 continue


c

      return
      end

c
c
c
c     Subroutine fderiv
c
c
c     Empirical, numerical derivatives of numerical LC model.
c
c
c     Purpose
c
c       Computes derivatives for numerical LC model with respect to
c       fitted parameters, for each LC point. 
c
c
c     Usage:
c
c    call fderiv (nterms,iqua,r1,r2,ii,dj,deltaa,a,nptos,icod,pre,
c                fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,deriv)
c
c
c     Description of variables:
c 
c       nterms - number of parameters being fitted
c       iqua   - parameter key for fit:
c                1 = fit it
c                0 = do not fit it
c
c       r1     - occultator radius (arcsec)
c       r2     - occulted radius   (arcsec)
c
c       ii     - i-th LC point
c       a      - vector of parameters
c       nterms - number of parameters 
c       deriv  - estimated derivatives of numerical LC model, with respect
c                to each parameter, for each LC point
c
c       deltaa - parameter steps for empirical derivative computations
c
c
c
c       a(1) = albedo ratio occultator/occulted (eclipsed/eclipsed)
c       a(2) = impact parameter (arcsec)
c       a(3) = central instant (DJ - 2400000.5D0)
c       a(4) = relative velocity (arcsec/dj)
c
c
c       icod   - key:
c                01: occultation model
c                02: eclipse model
c
c
c       iv     - number of points furnished to computing numerical model
c                (default = 1 point; evaluates each observation at a time)
c       pre    - scale factor km/pixel (surface resolution of numerical model)
c       flux   - fitted flux ratio from numerical model
c	fase1  -  vector with phase angles for occulted/eclipsed satellite 1 for each
c                 observation
c	fase2  -  vector with phase angles for occulting/eclipsing satellite 2 for each
c                 observation
c	Dir1   -  vector with inclination angles of line containing semi-ellipse focii
c                 of occulted/eclipsed satellite 1
c	Dir2   -  vector with inclination angles of line containing semi-ellipse focii
c                 of occulting satellite 2
c	Dir3   -  vector with inclination angles of line containing semi-ellipse focii
c                 of eclipsing shadow
c	cosbeta - vector containing angles between satellite heliocentric vectors for
c                  computing distances between
c                  eclipsed satellite and Sun
c       modVs1 - distance from occulted/eclipsed satellite 1 to Sun
c       modVs2 - distance from occulting/eclipseing satellite 2 to Sun
c
c
c
c
c
c
c     Outside the event, for all parameters we get:
c
c
c     dF/parameter = 0
c
c
c     Within event range, derivatives are empirically determined for each parameter,
c     using parameter steps deltaa furnished by the user.
c
c 
c     Last modification: M. Assafin    15/Nov/2010
c
c
c

      subroutine fderiv (nterms,iqua,r1,r2,ii,dj,deltaa,a,nptos,icod,
     ?pre,fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,modVs2,deriv,
     ?Fl,jnum3,gamaf)



      implicit real *8 (a-h,o-z)

      real*8 modVs1(100000),modVs2(100000)

      integer*8 iv,icod

      real*8 Fl(100000,2)

      real*8 gamaf

      integer*4 jnum3

      dimension deltaa(4),a(4),deriv(4),dj(100000),iqua(4)

      dimension fase1(100000),fase2(100000),Dir1(100000),Dir2(100000),
     ?Dir3(100000),cosbeta(100000)


      common /a14/ierro

c

      pi=0.3141592653589793d1
      grarad=pi/180.d0
      radgra=180.d0/pi

c

      iv=1



c
c     Outside event (flux ratio = 1): all derivatives are set to zero
c
c
      
      deriv(1)=0.d0
      deriv(2)=0.d0
      deriv(3)=0.d0
      deriv(4)=0.d0
     
c
c     Finds out if ii-th LC point is outside event
c


      call funcao (iv,r1,r2,a(2),a(4),dj(1),a(3),icod,pre,a(1),
     ?flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru,rp,Fl,jnum3,gamaf)

      call funcao (iv,r1,r2,a(2),a(4),dj(nptos),a(3),icod,pre,a(1),
     ?flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),Dir2(nptos),
     ?Dir3(nptos),cosbeta(nptos),modVs1(nptos),modVs2(nptos),ru,rp,
     ?Fl,jnum3,gamaf)

      flmax=dmax1(flmax1,flmaxn)

      call funcao (iv,r1,r2,a(2),a(4),dj(ii),a(3),icod,pre,a(1),
     ?flux,fase1(ii),fase2(ii),Dir1(ii),Dir2(ii),Dir3(ii),
     ?cosbeta(ii),modVs1(ii),modVs2(ii),ru,rp,Fl,jnum3,gamaf)


      flux=flux/flmax


      if (flux.ge.1.d0) return



c
c     Only user-defined parameters to be fitted will have derivatives evaluated,
c     otherwise derivatives are set to zero (parameters will be treated as constants).
c


      jj=0

      do 100 j=1,nterms

      if (iqua(j).ne.1) go to 100

      jj=jj+1

c
c     Computes empirically the derivatives based on furnished deltaa parameter steps
c



      aj=a(j)
      delta=deltaa(j)
      a(j)=aj+delta

      call funcao (iv,r1,r2,a(2),a(4),dj(1),a(3),icod,pre,a(1),
     ?flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru,rp,Fl,jnum3,gamaf)

      call funcao (iv,r1,r2,a(2),a(4),dj(nptos),a(3),icod,pre,a(1),
     ?flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),Dir2(nptos),
     ?Dir3(nptos),cosbeta(nptos),modVs1(nptos),modVs2(nptos),ru,rp,
     ?Fl,jnum3,gamaf)

      flmax=dmax1(flmax1,flmaxn)

      call funcao (iv,r1,r2,a(2),a(4),dj(ii),a(3),icod,pre,a(1),
     ?flux,fase1(ii),fase2(ii),Dir1(ii),Dir2(ii),Dir3(ii),
     ?cosbeta(ii),modVs1(ii),modVs2(ii),ru,rp,Fl,jnum3,
     ?gamaf)


      yfit1=flux/flmax
      
c

      a(j)=aj-delta


      call funcao (iv,r1,r2,a(2),a(4),dj(1),a(3),icod,pre,a(1),
     ?flmax1,fase1(1),fase2(1),Dir1(1),Dir2(1),Dir3(1),
     ?cosbeta(1),modVs1(1),modVs2(1),ru,rp,Fl,jnum3,gamaf)

      call funcao (iv,r1,r2,a(2),a(4),dj(nptos),a(3),icod,pre,a(1),
     ?flmaxn,fase1(nptos),fase2(nptos),Dir1(nptos),Dir2(nptos),
     ?Dir3(nptos),cosbeta(nptos),modVs1(nptos),modVs2(nptos),ru,rp,
     ?Fl,jnum3,gamaf)

      flmax=dmax1(flmax1,flmaxn)

      call funcao (iv,r1,r2,a(2),a(4),dj(ii),a(3),icod,pre,a(1),
     ?flux,fase1(ii),fase2(ii),Dir1(ii),Dir2(ii),Dir3(ii),
     ?cosbeta(ii),modVs1(ii),modVs2(ii),ru,rp,Fl,jnum3,gamaf)


      yfit2=flux/flmax

      deriv(jj)=(yfit1-yfit2)/(2.d0*delta)

      a(j)=aj



 100  continue

c

      return
      end



c
c
c       Function qiquad
c
c
c       Purpose
c
c
c       Computes reduced chi-square of fitting.
c
c       qiquad =   [ sum (observed_curve - fitted_curve)**2 ]  /  nfree
c
c
c       Usage  
c
c        result =  qiquad (nptos,cflux,free,a,itira,fluxo)
c
c     Description of variables:
c 
c
c
c       nptos  - number of LC points
c       cflux  - observed LC flux ratio
c       fluxo  - fitted flux ratio from numerical model
c       free   - number of degrees of freedom
c
c
c       Last modification: M. Assafin   12/Nov/2010
c
c
c


      double precision function qiquad (nptos,cflux,free,itira,fluxo)


      implicit real*8 (a-h,o-z)

      dimension cflux(100000),itira(100000),fluxo(100000)


      common /a14/ierro

c

      chisq = 0.d0
      qiquad=0.d0

c

      if (free.le.0.d0) then
      ierro=1
      return
      endif

c


      do  i = 1,nptos
      if (itira(i).eq.0) then
      chisq = chisq + (cflux(i)-fluxo(i))**2
      endif
      enddo


c
c     Divide by the number of degrees of freedom
c

      qiquad = chisq / free

      return
      end






c
c    
c     Subrotine desvio
c
c     Computes mean and standard deviation about the mean
c
c
c     input variables:
c
c        xvam  = sum of point values
c        xvas  = sum of square of values
c
c     output variables:
c
c        xvam  = mean
c        xvas  = standard deviation about that mean
c
c
c     Last modification:  M. Assafin   12/Nov/2010
c
c


      subroutine desvio (nest,xvam,xvas)

      implicit real*8 (a-h,o-z)

c

      dnove=99.999d0

c

      if (nest.le.1) return

      exmed=xvam/nest

c


      if (nest.eq.2) then

      xvas=dsqrt(dabs(2.d0*xvas-xvam**2))
      xvam=exmed

      return

      endif

c

      raiz=xvas-2.d0*exmed*xvam+nest*exmed**2

      if (raiz.lt.0.d0) then

      xvas=0.d0

      else

      xvas=dsqrt(raiz/(nest-1.d0))

      endif
c

      xvam=exmed


      return

      end





c
c    
c     Subrotine radec
c
c     Computes (RA,Dec) from 3-D position vector
c
c     n   = number of points
c
c     Vu  = position vector
c
c     RA  = degrees
c     Dec = degrees
c
c
c     Last modification:  M. Assafin   18/Nov/2010
c
c


      subroutine radec (n,Vu,ura2,ude2)

      implicit real*8 (a-h,o-z)

      dimension Vu(100000,3),ura2(100000),ude2(100000)

c

      pi=0.3141592653589793d1
      grarad=pi/180.d0
      radgra=180.d0/pi

c

      do i=1,n

      vx=Vu(i,1)
      vy=Vu(i,2)
      vz=Vu(i,3)

      dnorm=dsqrt(vx**2+vy**2+vz**2)

      vx=vx/dnorm
      vy=vy/dnorm
      vz=vz/dnorm

c

      auy=dabs(dasin(dabs(vz)))
      dec=radgra*auy
      if (vz.lt.0.d0) dec=-dec

c

      dcd=dabs(dcos(grarad*dec))
      
      aux=vx/dcd
      auy=vy/dcd

      aut=dabs(datan2(dabs(auy),dabs(aux)))

      rac=aut

      if (aux.ge.0.d0) then
       if (auy.lt.0.d0) rac=2.d0*pi-aut
      else
       if (auy.ge.0.d0) then
        rac=pi-aut
       else
        rac=pi+aut
       endif
      endif

      rac=radgra*rac

      ura2(i)=rac
      ude2(i)=dec


      enddo

c

      return
      end






      subroutine  funcao (t,R1,R2,deltay,vel,tempo,tcentral,cod,
     ?pre,ralbedo,F,fase1,fase2,Dir1,Dir2,Dir3,cosbeta,modVs1,
     ?modVs2,Ru,Rp,Fl,jnum3,gamaf)
      implicit none
c--------------------------------------------------------------------------
c Numeric Simulator of Mutual Events
c Sub-routine used for numerical simulation of eclipses and 
c occultation between satelites considering the solar fase
c angle and orbital inclination
c ltima atualizao: Alex Dias de Oliveira, 03/11/2010
      integer*8 i,j,n,cod,q,t,g1,g2,idim
      integer*4 ierro
      real*8 S1,S2,L1,l2,R1,R2,Rc1,Rc2,Pre,tetas,tetass,k,Rp1,Rp2,Rcp,
     ?Fsol,Ru,Rp,Rpu,Rpp,Rs,Dp1s,Dp2s,soma,kapa_eps,ModVs1,e1,e2,
     ?foco1,foco2,Dfx11,Dfx12,Dfx21,Dfx22,Dfy11,Dfy12,Dfy21,Dfy22,
     ?Df11,Df12,Df21,Df22,Ds1,x2,ModVs2,Rss,Dpcs,D1s,D2s,Du,Dp,Dpu,
     ?Dpp,focou,focop,Ds2,pi,gama,deltay,Rps,Rpss,Dcs,Dfx12u,Dfx12p,
     ?Dfy12u,Dfy12p,Dfx22u,Dfx22p,Dfy22u,Dfy22p,Df12u,Df22u,Df12p,
     ?Df22p,Ds2u,Ds2p,Dp12x,Dp12y,albd1,albd2,fluxo,ralbedo,
     ?tcentral,Esc3,vel,velp,modVl1,kapa,Esc2,fase_eps,ap,y2,y1,
     ?x1,au,Re,S2c,alpha,deltapy,Dp12,D12,bu,bp,F,fase1,fase2,Dir1,
     ?Dir2,Dir3,cosbeta,tempo,L2e,S2e,deltax,norma1,norma2

      real*8 A(10000,10000)

      real*8 Fl(100000,2)

      real*8 gamaf

      integer*4 jnum3
      
      common /a14/ierro
c--------------------------------------------------------------------------
c input variables:
c  t             --> Number of lines that each vector will have
c                    (Number of images)
c  R1          -->  Radius of the satelite 1 (eclipsed/occulted)
c  R2          -->  Radius of the satelite 2 (eclipsing/occulting)
c  deltay    --> Impact parameter 
c  vel          --> Relative speed between satelites
c  tempo     --> Vector containing the moments of each image
c tcentral  --> Central Instant
c fase1     --> Vector  with the solar fase angles of the
c                      satelite 1
c fase2     --> Vector  with the solar fase angles of the
c                      satelite 2
c Dir1      --> vetor que ir conter os ngulos de inclinao da reta
c que contm os focos da semi-elipse do satlite 1
c Dir2      --> vetor que ir conter os ngulos de inclinao da reta
c que contm os focos da semi-elipse do satlite 2
c Dir3      --> vetor que ir conter os ngulos de inclinao da reta
c que contm os focos da elipse formada pela sombra 
c cosbeta  --> Vetor que ir conter os ngulos entre os vetores
c heliocntricos de posio dos satlites usados para
c       Determinar a distncia entre o satlite eclipsado e o sol.
c
c cod       --> Nmero inteiro usado para designar se o evento
c reduzido  uma ocultao (01) ou um eclipse (02)
c pre       --> Fator de escala km/pixel a ser utilizado na 
csimulao (-99 caso no seja conhecido tal valor)
c ralbedo   --> Razo de albedos dos satlites 
c (satlite1/satlite2)
c F         --> Vetor que ir receber os valores normalizados 
c do fluxo total dos satlites para cada instante de tempo
c--------------------------------------------------------------------------
c Para construir o evento na matriz de simulao as distncias
c localizadas no plano do observador so corrigidas por um
c fator de escala que ir converter as distncias de km para 
c pixels usando um fator de correo k que  fornecido pelo 
c observador e depende da preciso km/pixel das imagens. 
c Caso este valor no seja conhecido basta o observador
c fornecer o valor arbitrrio -99 para este parmetro que
c o software ir assumir uma escala onde o raio do menor
c do dois satlites Possuir 1000 pixels.
c--------------------------------------------------------------------------
c Alocao dos vetores utilizados na simulao
c--------------------------------------------------------------------------
      ierro = 0
      Fluxo = 0.d0
      Rs = 695500.d0            
      pi = 4*datan(1.d0)	   
      idim = 5000
c--------------------------------------------------------------------------
      if (pre.eq.-99) then
      k = (dmin1(R1,R2))/1000
      else
      k = pre
      endif 
c O teste anterior verificou se a escala de precio
c km/pixel foi fornecida pelo usurio e caso no
c tenho sido fornecida. O software cria uma propria
c escala e a partir disso ir ger a correspondecia 
c em pixel das distancias para a matriz de simulao
c--------------------------------------------------------------------------
cTeste para verificar se o fenomeno a ser simulado
c  uma ocultao ou Eclipse	
      if (cod .eq. 1) then            
      goto 201                              
      else
      if (cod .eq. 2) then
      goto 301
      endif
      endif
c--------------------------------------------------------------------------
c As operaes que seguem so a obteno das
c coordenadas dos vetores que no so fornecidos 
c na entrada e o clculo dos ngulos entre os vetores
c que se fizerem necessrios para determinar a fase 
c solar e a inclinao da orbita dos satlites
c--------------------------------------------------------------------------
c==========================================================================
c----------------SIMULATION OF THE OCCULTATION-----------------------------
c--------------------------------------------------------------------------
c--------------------------------------------------------------------------
 201  D1s = modVs1   
      D2s = modVs2
c--------------------------------------------------------------------------
c Abaixo so calculados os mdulos dos vetores que 
c sero usados para determinao de ngulos e outros
c parmetros
c--------------------------------------------------------------------------
 
c Conversao das coordenadas km para pixel usando a 
c escala definida k (km/pixel) 	
      Rp1 = R1/k
      Rp2 = R2/k
      deltapy = deltay/k
      velp = vel/k
      Ru = 0.d0
      Rp = 0.d0
c  Determinao do tamanho da matriz de simulao
      e1 = dsin(fase1)
      e2 = dsin(fase2)
      foco1 = e1*Rp1
      foco2 = e2*Rp2
      x1 = idim/2                                
      y1 = idim/2                     
      x2 = x1 +  velp*(tempo - tcentral)
      y2 = y1 + deltapy 
      deltax = dsqrt((x2-x1)**2 + (y2-y1)**2)
      albd2 = 1.0d0
      albd1 = albd2*ralbedo
      norma1 = (pi*(Rp1**2)*(1.0d0 + dsqrt(1.0d0 - (e1**2))))/2.0d0 
      norma2 = (pi*(Rp2**2)*(1.0d0 + dsqrt(1.0d0 - (e2**2))))/2.0d0
      if (dabs(deltax) .gt. dabs(Rp1+Rp2)) then
      fluxo = fluxo + norma1*albd1 + norma2*albd2 
      F = fluxo
      go to 500
      else
      if (dabs(deltax + Rp2) .le. Rp1) then
      n = idnint(2*(dmax1(Rp2,Rp1) + 2.0d0))
      else
      n = idnint(2*(dabs(deltax) + Rp2 + 2.0d0))
      end if 
      if (n .gt. 2*idim) then
      ierro = 1
      F = -10.d0
      return
      endif
      g1 = idim/2 - n/2
      g2 = idim/2 + n/2                           
c--------------------------------------------------------------------------
      do j = g1,g2
      S1 = 0.0d0
      S2 = 0.0d0
      L1 = 0.0d0
      L2 = 0.0d0
      Rc1 = 0.0d0
      Rc2 = 0.0d0
c---------------------------------------------------------------------------
      do i = g1,g2
      S1 = dabs(X1 - i)		       
      S2 = dabs(X2 - i)		       
      L1 = dabs(Y1 - j)		       
      L2 = dabs(Y2 - j)		       
      Rc1 = dsqrt((L1**2) + (S1**2))
      Rc2 = dsqrt((L2**2) + (S2**2))
c--------------------------------------------------------------------------
c Em funo do ngulo de fase do sol a figura dos 
c satlites para um obserdador na terra  composta 
c de um semi-crculo e uma semi elipse, cujos focos se 
c localizam em uma reta inclinada de acordo com a 
c inclinao do plano do movimento relativo dos
c satlites (Dir). 
c--------------------------------------------------------------------------
      Dfx11 = dabs(X1 - i - foco1*dsin(Dir1)) 
      Dfy11 = dabs(Y1 - j + foco1*dcos(Dir1))
      Dfx21 = dabs(X1 - i + foco1*dsin(Dir1)) 
      Dfy21 = dabs(Y1 - j - foco1*dcos(Dir1)) 
      Dfx12 = dabs(X2 - i - foco2*dsin(Dir2)) 
      Dfy12 = dabs(Y2 - j + foco2*dcos(Dir2)) 
      Dfx22 = dabs(X2 - i + foco2*dsin(Dir2)) 
      Dfy22 = dabs(Y2 - j - foco2*dcos(Dir2)) 
c-------------------------------------------------------------------------
      Df11 = dsqrt(Dfy11**2 + Dfx11**2) 
      Df21 = dsqrt(Dfy21**2 + Dfx21**2) 
      DS1 = Df11 + Df21  
      Df12 = dsqrt(Dfy12**2 + Dfx12**2) 
      Df22 = dsqrt(Dfy22**2 + Dfx22**2) 
      DS2 = Df12 + Df22                
c--------------------------------------------------------------------------
      if (Rc2 .gt. Rp2) then   
      if (Rc1 .gt. Rp1) then   
      A(j,i) = 0.0d0             
      else                 
      if (fase1 .ne. 0.0d0) then  
      if (i .gt. X1 + dtan(Dir1)*(Y1 - j)) then
      if ( DS1 .gt. 2*Rp1) then 
      A(j,i) = 0.0d0           
      else
      A(j,i) = albd1
      endif
      else  
      A(j,i) = albd1    
      endif
      else  
      A(j,i) = albd1
      endif
      endif
c--------------------------------------------------------------------------
      else                                     
      if (fase2 .ne. 0.0d0) then           
      if (i .gt. X2 + dtan(Dir2)*(Y2 - j) ) then
      if ( DS2 .gt. 2*Rp2) then 
c--------------------------------------------------------------------------			 
      if (Rc1 .gt. Rp1) then
      A(j,i) = 0.0d0 
      else                                         
      if (i .gt. X1 + dtan(Dir1)*(Y1 - j) ) then 
      if ( DS1 .gt. 2*Rp1) then                  
      A(j,i) = 0.0d0
      else                                       
      A(j,i) = albd1
      endif
      else               
      A(j,i) = albd1           
      endif
      endif
c--------------------------------------------------------------------------
      else                            
      A(j,i) = albd2 
      endif
      else                                   
      A(j,i) = albd2
      endif
      else                                   
      A(j,i) = albd2
      endif
      endif
c--------------------------------------------------------------------------
      fluxo = fluxo + A(j,i)   
      enddo
      enddo
      F = fluxo
      go to 500 
      endif
c--------------------------------------------------------------------------
c==========================================================================
c--------------------SIMULAO DO ECLIPSE----------------------------------
c--------------------------------------------------------------------------
 301  D1s = modVs1*cosbeta
      D2s = modVs2
      D12 = Ds1 - Ds2
      Du  = ((D1s - D2s)*(R2 - Rs) + R2*D2s)/(Rs-R2)
      Dp  = (R2*D2s)/(Rs+R2)  
      Ru  = (Du*R2)/(dsqrt((Du+D1s-D2s)**2 - R2**2))                 
      Rp  = (R2*(D1s - D2s + Dp))/dsqrt(Dp**2 - R2**2)  	
      Rss = (R2*D1s)/((D1s - D2s)) 
c--------------------------------------------------------------------------
c Converso de velocidades e distncias de km e km/s para pixel e pixel/s
c usando o fator de escala k
c--------------------------------------------------------------------------
      Dp1s = D1s/k
      Dp2s = D2s/k
      Dp12 = D12/k                                   
      Rp1 = R1/k
      Rp2 = R2/k
      Rpu = Ru/k
      Rpp = Rp/k
      Dpu = Du/k
      Dpp = Dp/k
      Rpss = Rss/k
      Rps = Rs/k           
      velp = vel/k
      deltapy = deltay/k
      n = idnint(2*(dabs(Rp2 + 8.0d0))) 
      x1 = idim/2                                  
      y1 = idim/2 
      g1 = idim/2 - n/2
      g2 = idim/2 + n/2  
      if (n .gt. 2*idim) then
      ierro = 1
      F = -10.d0
      return
      endif
      x2 = x1 + velp*(tempo - tcentral)    
      y2 = y1 + deltapy
      deltax = dsqrt((x1-x2)**2 + (y1-y2)**2)                    
      e1 = dsin(fase1)
      e2 = dsin(fase2)
      foco1 = e1*Rp1
      foco2 = e2*Rp2
      bu = Rpu
      bp = Rpp
      au = Rpu/dcos(fase1)
      ap = Rpp/dcos(fase1)
      focou = dsqrt(au**2 - bu**2)					    	    
      focop = dsqrt(ap**2 - bp**2)
      albd2 = 1.0d0
      albd1 = albd2
      norma1 = (pi*(Rp1**2)*(1.0d0 + dsqrt(1.0d0 - (e1**2))))/2.0d0
c     if (deltax .gt. (Rp1+ap/2.d0)) then
      if (dabs(deltax) .gt. dabs(Rp1+ap)) then
      fluxo = fluxo + norma1*albd1
      F = fluxo
      go to 500
      else
c--------------------------------------------------------------------------
      do j = g1,g2
      S1 = 0.0d0
      S2 = 0.0d0
      L1 = 0.0d0
      L2 = 0.0d0
      Rc1 = 0.0d0
      Rcp = 0.0d0
      Dcs = 0.0d0
c--------------------------------------------------------------------------
      do i = g1,g2
      S1 = dabs(X1 - i)		  
      S2 = dabs(X2 - i)		
      L1 = dabs(Y1 - j)		 
      L2 = dabs(Y2 - j)		  
      Rc1 = dsqrt((L1**2) + (S1**2))	  
      Rcp = dsqrt((L2**2) + (S2**2))   
      L2e = L2*dsqrt(((dsin(Dir3))**2)*((dcos(fase1))**2) + 
     ?((dcos(Dir3))**2))
      S2e = S2*dsqrt(((dcos(Dir3))**2)*((dcos(fase1))**2) +
     ?((dsin(Dir3))**2))
      Re = dsqrt((L2e**2)+(S2e**2)) 
c---------------------------------------------------------------------------
c Em funo do ngulo de fase do sol, a penumbra e a umbra sofrem uma 
c deformao em funo da interseo do cone de sombra e do plano do 
c observador que  perpendicular a linha que liga a terra ao ponto onde o 
c ocorre o instante central do eclipse. Esta figura de intereseo  
c so duas elipses concntricas que possuem como semieixo menor 
c Os raios da umbra e da penumbra, respectivamente, e os focos localizados
c em uma reta cuja inclinao  a inclinao Entre a linha que une o 
c centr do satlite e a sombra e a direo da velocidade do satlite em 
c relao a sombra
c--------------------------------------------------------------------------
      Dfx11 = dabs(X1 - i - foco1*dsin(Dir1))	 
      Dfy11 = dabs(Y1 - j + foco1*dcos(Dir1))	 
      Dfx21 = dabs(X1 - i + foco1*dsin(Dir1))	
      Dfy21 = dabs(Y1 - j - foco1*dcos(Dir1))	 
      Dfx12u = dabs(X2 - i - focou*dcos(Dir3))  
      Dfy12u = dabs(Y2 - j + focou*dsin(Dir3))   
      Dfx22u = dabs(X2 - i + focou*dcos(Dir3)) 
      Dfy22u = dabs(Y2 - j - focou*dsin(Dir3))  
      Dfx12p = dabs(X2 - i - focop*dcos(Dir3))   
      Dfy12p = dabs(Y2 - j + focop*dsin(Dir3))
      Dfx22p = dabs(X2 - i + focop*dcos(Dir3))   
      Dfy22p = dabs(Y2 - j - focop*dsin(Dir3))  
c-------------------------------------------------------------------------
      Df11 = dsqrt(Dfy11**2 + Dfx11**2)  
      Df21 = dsqrt(Dfy21**2 + Dfx21**2)
      DS1 = Df11 + Df21                
      Df12u = dsqrt(Dfy12u**2 + Dfx12u**2)
      Df22u = dsqrt(Dfy22u**2 + Dfx22u**2)
      DS2u = Df12u + Df22u                
      Df12p = dsqrt(Dfy12p**2 + Dfx12p**2)
      Df22p = dsqrt(Dfy22p**2 + Dfx22p**2)
      DS2p = Df12p + Df22p                
c--------------------------------------------------------------------------
      if (fase1 .ne. 0.0d0) then   	       
      if ( Rc1 .lt. Rp1) then  
      if (i .gt. X1 + dtan(Dir1)*(Y1 - j)) then  
      if ( DS1 .gt. 2*Rp1) then                     
      A(j,i) = 0.0d0                               
      else                                             
      if (Ds2p .lt. 2*ap) then                      
      if (Ds2u .lt. 2*au) then                     
      A(j,i) = 0.0d0      
      else                                                                                 
c=======================================================================
      Dcs = (Re*Dp2s)/(Dp1s - Dp2s) 
      tetass = dacos((Rpss**2 - Rps**2 + Dcs**2)/(2*Rpss*Dcs))
      tetas = dacos((Rps**2 - Rpss**2 + Dcs**2)/(2*Rps*Dcs))
      Fsol =((Rpss**2)*tetass+(Rps**2)*tetas-Dcs*Rpss*dsin(tetass))/
     ?(pi*(Rps**2))
      if ((Rpss**2 - Rps**2 + Dcs**2)/(2*Rpss*Dcs) .lt. 1.0d0) then
      if ((Rps**2 - Rpss**2 + Dcs**2)/(2*Rps*Dcs) .lt. 1.0d0) then
      Fsol =((Rpss**2)*tetass + (Rps**2)*tetas - Dcs*Rpss*dsin(tetass))/
     ?(pi*(Rps**2))     
c========================================================================
      call penumbra (Dcs,Rpss,gamaf,Rps,Fl,jnum3)
      gama = 1 - Fsol 

c=======================================================================     
      A(j,i) = albd1*gamaf
      else 
      A(j,i) = 0.d0
      endif
      else
      A(j,i) = 0.d0
      endif
      endif
      else                                        
      A(j,i) = albd1
      endif
      endif
      else                                       
      if (Ds2p .lt. 2*ap) then                
      if (Ds2u .lt. 2*au) then             
      A(j,i) = 0.0d0
      else 
c=====================================================================                                                           
      Dcs = (Re*Dp2s)/(Dp1s - Dp2s) 
      tetass = dacos((Rpss**2 - Rps**2 + Dcs**2)/(2*Rpss*Dcs))
      tetas = dacos((Rps**2 - Rpss**2 + Dcs**2)/(2*Rps*Dcs))
      Fsol =((Rpss**2)*tetass+(Rps**2)*tetas-Dcs*Rpss*dsin(tetass))/
     ?(pi*(Rps**2))
      if ((Rpss**2 - Rps**2 + Dcs**2)/(2*Rpss*Dcs) .lt. 1.0d0) then
      if ((Rps**2 - Rpss**2 + Dcs**2)/(2*Rps*Dcs) .lt. 1.0d0) then
      Fsol =((Rpss**2)*tetass + (Rps**2)*tetas - Dcs*Rpss*dsin(tetass))/
     ?(pi*(Rps**2))
c======================================================================
      call penumbra (Dcs,Rpss,gamaf,Rps,Fl,jnum3)
      gama = 1 - Fsol   

c=======================================================================  
      A(j,i) = albd1*gamaf
      else 
      A(j,i) = 0.d0
      endif
      else 
      A(j,i) = 0.d0
      endif
      endif
      else                                    
      A(j,i) = albd1
      endif
      endif
      else                                       
      A(j,i) = 0.0d0
      endif 
c--------------------------------------------------------------------------
      else                                
      if (Rcp .gt. Rpp) then              
      if (Rc1 .gt. Rp1) Then              
      A(j,i) = 0.0d0                         
      else                                  
      A(j,i) = albd1
      endif 
      else                                  
      if (Rcp .gt. Rpu) then             
      if (Rc1 .gt. Rp1) then        
      A(j,i) = 0.0d0
      else  
c============================================================================                                 
      Dcs = (Re*Dp2s)/(Dp1s - Dp2s) 
      tetass = dacos((Rpss**2 - Rps**2 + Dcs**2)/(2*Rpss*Dcs))
      tetas = dacos((Rps**2 - Rpss**2 + Dcs**2)/(2*Rps*Dcs))
      Fsol =((Rpss**2)*tetass + (Rps**2)*tetas - Dcs*Rpss*dsin(tetass))/
     ?(pi*(Rps**2))
      if ((Rpss**2 - Rps**2 + Dcs**2)/(2*Rpss*Dcs) .lt. 1.0d0) then
      if ((Rps**2 - Rpss**2 + Dcs**2)/(2*Rps*Dcs) .lt. 1.0d0) then
      Fsol =((Rpss**2)*tetass + (Rps**2)*tetas - Dcs*Rpss*dsin(tetass))/
     ?(pi*(Rps**2))   
c============================================================================== 
      call penumbra (Dcs,Rpss,gamaf,Rps,Fl,jnum3)  
      gama = 1 - Fsol 
   
c================================================================================   
      A(j,i) = albd1*gamaf
      else
      A(j,i) = 0.d0
      endif
      else
      A(j,i) = 0.d0
      endif
      endif
      else                                  
      A(j,i) = 0.0d0
      endif
      endif
c--------------------------------------------------------------------------
      end if 	
c--------------------------------------------------------------------------
      fluxo = fluxo + A(j,i)
      enddo
      enddo
      F = fluxo
      end if
 500  return
      end 
      
      


      

      
      subroutine  fase (t,tempo,V1,V2,Vst,fase1,fase2,Dir1,Dir2,Dir3,
     ?cosbeta,ModVs1,ModVs2,Vu)
      implicit none
c-------------------------------------------------------------------------
c FASE
c Sub-rotina usada para calcular os ngulos envolvidos na simulao 
c dos eventos a partir dos vetres topocntricos fornecidos na entrada.
c 1  o satlite eclipsado ou ocultado e 2  o satlite eclipsante
c ou ocultante
c Ultima atualizao: Alex Dias de Oliveira, 19/11/2010
      integer*8 i,j,n,q,t
      real*8 modVst,modNeps,modNl1,modV1,modV2,modNl2,Esc1,Esc2,Esc3,
     ?modVl1,pi,modVl2,sigma,gama,kapa,eps,ro,CD,AD,Stg1,BD,AB,BF,EB,DE,
     ?CE,const,vec1,vec2,vec3,EF
      real*8 Vst(100000,3),Vs1(100000,3),Vs2(100000,3),Neps(100000,3),
     ?Nlb1(100000,3),Nlb2(t,3),Vel1(100000,3),Vel2(100000,3),
     ?VelR(100000,3)
      real*8 V1(100000,6),V2(100000,6)
      real*8 tempo(100000),fase1(100000),fase2(100000),Dir1(100000),
     ?Dir2(100000),Dir3(100000),cosbeta(100000),modVs1(100000),
     ?modVs2(100000),Vu(100000,3),Vsu(100000,3)

c--------------------------------------------------------------------------
c Variveis de entrada:
c t       --> Numero de linhas que cada vetor tera (Numero de imagens usadas)
c tempo   --> Vetor contendo os instantes para cada imagem (em data juliana)
c V1      --> vetor contendo as coordenadas e velocidades topocntricas do 
c             satlite 1 (eclipsado/ocultado) em km e km/s 
c V2      --> vetor contendo as coordenadas e velocidades topocntricas do 
c             satlite 2 (eclipsado/ocultado) em km e km/s
c Vst     --> vetor contendo as coordenadas e velocidades topocntricas do
c              sol em km e km/s
c fase1   --> Vetor que ir conter os ngulos de fase do satlite 1 para
c             cada instante de tempo
c fase2   --> Vetor que ir conter os ngulos de fase do satlite 2 para
c             cada instante de tempo
c Dir1    --> vetor que ir conter os ngulos de inclinao da reta que
c             contm os focos da semi-elipse do satlite 1
c Dir2    --> vetor que ir conter os ngulos de inclinao da reta que 
c             contm os focos da semi-elipse do satlite 2
c Dir3    --> vetor que ir conter os ngulos de inclinao da reta que
c             contm os focos da elipse formada pela sombra 
c cosbeta--> Vetor que ir conter os ngulos entre os vetores 
c             heliocntricos de posio dos satlites usados para
c      	    Determinar a distncia entre o satlite eclipsado e o sol.

      pi = 4*datan(1.0d0)	  
c--------------------------------------------------------------------------
      do q = 1,t
c     Calculo das coordenadas dos demais vetores envolvidos usando os 3 
c     vetores topocentricos inicialmente fornecidos
      Vs1(q,1) = V1(q,1) - Vst(q,1)                       
      Vs1(q,2) = V1(q,2) - Vst(q,2)	     
      Vs1(q,3) = V1(q,3) - Vst(q,3)
      Vs2(q,1) = V2(q,1) - Vst(q,1)
      Vs2(q,2) = V2(q,2) - Vst(q,2)
      Vs2(q,3) = V2(q,3) - Vst(q,3)
      Neps(q,1) = Vs2(q,2)*Vs1(q,3) - Vs2(q,3)*Vs1(q,2)
      Neps(q,2) = Vs2(q,3)*Vs1(q,1) - Vs2(q,1)*Vs1(q,3)
      Neps(q,3) = Vs2(q,1)*Vs1(q,2) - Vs2(q,2)*Vs1(q,1)
      Nlb1(q,1) = V1(q,2)*Vst(q,3) - V1(q,3)*Vst(q,2)
      Nlb1(q,2) = V1(q,3)*Vst(q,1) - V1(q,1)*Vst(q,3)
      Nlb1(q,3) = V1(q,1)*Vst(q,2) - V1(q,2)*Vst(q,1)
      Nlb2(q,1) = V2(q,2)*Vst(q,3) - V2(q,3)*Vst(q,2)
      Nlb2(q,2) = V2(q,3)*Vst(q,1) - V2(q,1)*Vst(q,3)
      Nlb2(q,3) = V2(q,1)*Vst(q,2) - V2(q,2)*Vst(q,1)
      velR(q,1) = V2(q,4) - V1(q,4)
      velR(q,2) = V2(q,5) - V1(q,5)
      velR(q,3) = V2(q,6) - V1(q,6)
      Vel1(q,1) = V1(q,2)*VelR(q,3) - V1(q,3)*VelR(q,2)
      Vel1(q,2) = V1(q,3)*VelR(q,1) - V1(q,1)*VelR(q,3)
      Vel1(q,3) = V1(q,1)*VelR(q,2) - V1(q,2)*VelR(q,1)
      Vel2(q,1) = V2(q,2)*VelR(q,3) - V2(q,3)*VelR(q,2)
      Vel2(q,2) = V2(q,3)*VelR(q,1) - V2(q,1)*VelR(q,3)
      Vel2(q,3) = V2(q,1)*VelR(q,2) - V2(q,2)*VelR(q,1)      
      modVs2(q) = dsqrt(Vs2(q,1)**2 + Vs2(q,2)**2 + Vs2(q,3)**2)
      modVs1(q) = dsqrt(Vs1(q,1)**2 + Vs1(q,2)**2 + Vs1(q,3)**2)
                      
      cosbeta(q)=((Vs1(q,1)*Vs2(q,1)+Vs1(q,2)*Vs2(q,2)+
     ?Vs1(q,3)*Vs2(q,3))/(modVs1(q)*modVs2(q)))
c--------------------------------------------------------------------------
c	Abaixo so calculados os mdulos dos vetores que sero usados para 
c     determinao de ngulos e outros parmetros
c--------------------------------------------------------------------------
      modV1 = dsqrt(V1(q,1)**2 + V1(q,2)**2 + V1(q,3)**2)
      modV2 = dsqrt(V2(q,1)**2 + V2(q,2)**2 + V2(q,3)**2)
      modVst = dsqrt(Vst(q,1)**2 + Vst(q,2)**2 + Vst(q,3)**2)
      modNeps = dsqrt(Neps(q,1)**2 + Neps(q,2)**2 + Neps(q,3)**2)
      modNl1 = dsqrt(Nlb1(q,1)**2 + Nlb1(q,2)**2 + 
     ?Nlb1(q,3)**2)
      modNl2 = dsqrt(Nlb2(q,1)**2 + Nlb2(q,2)**2 + 
     ?Nlb2(q,3)**2)
      modVl1 = dsqrt(Vel1(q,1)**2 + Vel1(q,2)**2 + Vel1(q,3)**2)
      modVl2 = dsqrt(Vel2(q,1)**2 + Vel2(q,2)**2 + Vel2(q,3)**2)
      fase1(q) = dasin(dsqrt((Vs1(q,2)*V1(q,3)-Vs1(q,3)*V1(q,2))**2+
     ?(Vs1(q,3)*V1(q,1)-Vs1(q,1)*V1(q,3))**2+
     ?(Vs1(q,1)*V1(q,2)-Vs1(q,2)*V1(q,1))**2)/(modVs1(q)*modV1))   
      fase2(q) = dasin(dsqrt((Vs2(q,2)*V2(q,3)-Vs2(q,3)*V2(q,2))**2+
     ?(Vs2(q,3)*V2(q,1)-Vs2(q,1)*V2(q,3))**2+
     ?(Vs2(q,1)*V2(q,2)-Vs2(q,2)*V2(q,1))**2)/(modVs2(q)*modV2)) 
      Esc1 = dsqrt((Vel1(q,2)*Nlb1(q,3)-Vel1(q,3)*Nlb1(q,2))**2+
     ?(Vel1(q,3)*Nlb1(q,1)-Vel1(q,1)*Nlb1(q,3))**2+
     ?(Vel1(q,1)*Nlb1(q,2)-Vel1(q,2)*Nlb1(q,1))**2)
      Esc2 = dsqrt((Vel2(q,2)*Nlb2(q,3)-Vel2(q,3)*Nlb2(q,2))**2+
     ?(Vel2(q,3)*Nlb2(q,1)-Vel2(q,1)*Nlb2(q,3))**2+
     ?(Vel2(q,1)*Nlb2(q,2)-Vel2(q,2)*Nlb2(q,1))**2)
      Esc3 = dsqrt((Vel1(q,2)*Nlb1(q,3)-Vel1(q,3)*Nlb1(q,2))**2+
     ?(Vel1(q,3)*Nlb1(q,1)-Vel1(q,1)*Nlb1(q,3))**2+
     ?(Vel1(q,1)*Nlb1(q,2)-Vel1(q,2)*Nlb1(q,1))**2)
      Dir1(q) = dasin(Esc1/(modVl1*modNl1))
      Dir2(q) = dasin(Esc2/(modVl2*modNl2))
      Dir3(q) = dasin(Esc3/(modVl1*modNl1))
c-------------------------------------------------------------------------
      gama = dacos((Vst(q,1)*V1(q,1)+Vst(q,2)*V1(q,2)+
     ?Vst(q,3)*V1(q,3))/(modVst*modV1))
      sigma = gama - (pi/2)
      vec2 = dsqrt(((V1(q,2)*Vs2(q,3)) - (V1(q,3)*Vs2(q,2)))**2 + 
     ?((V1(q,3)*Vs2(q,1)) - (V1(q,1)*Vs2(q,3)))**2 +
     ?((V1(q,1)*Vs2(q,2)) - (V1(q,2)*Vs2(q,1)))**2 )
      eps = dasin(vec2/(modV1*modVs2(q)))
      vec3 = dsqrt(((-Vst(q,2)*Vs2(q,3)) - (-Vst(q,3)*Vs2(q,2)))**2 + 
     ?((-Vst(q,3)*Vs2(q,1)) - (-Vst(q,1)*Vs2(q,3)))**2 +
     ?((-Vs2(q,1)*Vs2(q,2)) - (-Vst(q,2)*Vs2(q,1)))**2 )
      kapa = pi -ro - sigma
      ro = pi/2 + eps
      Stg1 = ((dtan((ro+sigma)/2))/(dtan((ro-sigma)/2))) 
      CD = (modVst*(Stg1 - 1))/(1+Stg1)
      AD = modVst*dsin(kapa)/dsin(ro)
      BD = AD/dsin(eps)
      AB = BD*dcos(eps) 
      if (AB .lt. modV1) then
      BF = modV1 - AB
      EF = BF*dsin(eps)
      EB = dsqrt(BF**2 - EF**2)
      DE = BD + EB
      CE = DE + CD
      else
      BF = AB - modV1
      EF = BF*dsin(eps)
      EB = dsqrt(BF**2 - EF**2)
      DE = BD - EB
      CE = DE + CD 
      end if     
      const = CE/modVs2(q)
      Vsu(q,1) = const*Vs2(q,1)
      Vsu(q,2) = const*Vs2(q,2)
      Vsu(q,3) = const*Vs2(q,3)
      Vu(q,1) = Vst(q,1) + Vsu(q,1)
      Vu(q,2) = Vst(q,2) + Vsu(q,2)
      Vu(q,3) = Vst(q,3) + Vsu(q,3)
c----------------------------------------------------------------------------
      enddo
      return
      end 



c======================================================================


      subroutine bordo (Fl,jnum3)
c     Subroutine that calculate the gradual darkening of the edge of the sun

       
      implicit none
      real*8 deltar,r1,r2,Rs,pi,alpha,teste1,teste2,k,m,p
      integer*8 i,l
      real*8 Fn(100000),Fl(100000,2),T(100000)
      integer*4 jnum3
c     
      pi = 4*datan(1.0d0)
      r1 = 0.25
      deltar = 0.001d0
      T(1) = 1.0d0
      Fl(1,2) = 1.0d0
      Fl(1,1) = r1

      alpha = 0.3d0
      l = 1
      m = 1.0d0
      p = 1.0d0
      jnum3 = 1 

      do i = 2,10000
1     if (l .eq. 1) then
      r1 = r1
      r2 = r1 + deltar
      else
      r1 = r2
      r2 = r2 + deltar
      endif
      T(i) = (dsqrt(1 - (r2)**2))**alpha
      teste1 = dabs(T(i-1) - T(i))
      if (teste1 .lt. 0.01d0) then
      p = p + 0.1d0
      deltar = deltar*p
      l = 1
      go to 1
      else
      if (teste1 .gt. 0.1d0) then
            m = m - 0.01d0
      deltar = deltar*m
      l = 1
      go to 1
      else
      Fl(i,2) = T(i)
c      Fl(i,2) = 1.0d0
      Fl(i,1) = r2

      jnum3 = jnum3+1
      l = 2
      deltar = 0.001d0
      m = 1.0d0	
      k = 1.0d0

      end if
      end if


      teste2 = 1 - r2
      if (teste2 .lt. 0.001d0) then
      go to 2
      end if
      end do

2     continue
      Fl(jnum3+1,2) = Fl(jnum3,2)
      Fl(jnum3+1,1) = 1.0d0
      end

c===============================================================================

      subroutine penumbra (Dcs,Rpss,gama,Rps,Fl,num)
      implicit none
      integer*4 num
      integer*8 i,j,k,ii,jj,s,ss,fim,si,kk
      real*8 fnorma,Dcs,Rpss,Rps,gama,pi,teste1,teste2,teste3,
     ?fluxo1,tetass,tetas
      real*8 Fl(100000,2),fluxo(100000),Fsol(100000)
c------------------------------------------------------------------------------      
      gama = 0.0d0
      pi = 4*datan(1.0d0)
      fim = num+1
      fluxo1 = 0.0d0
c-----------------------------------------------------------------------------
      fnorma = pi*((Fl(1,1)*Rps)**2)*Fl(1,2)
      do k = 2,fim
      fnorma = fnorma + pi*(((Fl(k,1)*Rps)**2)-
     ?((Fl(k-1,1)*Rps)**2))*Fl(k,2)
      end do

c-----------------------------------------------------------------------------
c=============================================================================
      teste1 = dabs(Dcs - Rpss)  
      

  
      if (teste1 .ge. (Fl(1,1)*Rps))  then
c-----------------------------------------------------------------------------

      if (Dcs .gt. Rpss) then
c--------------------------------------*------------------------------------	
 
      fluxo(1) = (pi*((Fl(1,1)*Rps)**2)*Fl(1,2))/fnorma

      s = 2

111   teste2 = dabs(Dcs - Rpss)
      
      if (teste2 .gt. (Fl(s,1)*Rps)) then
		 
      fluxo(s) = (pi*((Fl(s,1)*Rps)**2-(Fl(s-1,1)*Rps)**2))*Fl(s,2)
     ?/fnorma


      s = s+1     
      go to 111
      
 

      else
    
      if (s .eq. fim) then
      
      tetass = dacos((Rpss**2 - ((Fl(s,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
     
      tetas = dacos((((Fl(s,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(s,1)*Rps)*Dcs))
     
      Fsol(s) =((Rpss**2)*tetass + ((Fl(s,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass)) 
     
      Fluxo(s) = (((pi*(((Fl(s,1)*Rps)**2) - ((Fl(s-1,1)*Rps)**2))) -
     ?Fsol(s))*Fl(s,2))/fnorma       
 
    

c---------------------------------------------------------------------------	     
      else
     
      if (s .lt. fim) then
      
      tetass = dacos((Rpss**2 - ((Fl(s,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
      
      tetas = dacos((((Fl(s,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(s,1)*Rps)*Dcs))
      
      Fsol(s) =((Rpss**2)*tetass + ((Fl(s,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass)) 
      
      Fluxo(s) = (((pi*(((Fl(s,1)*Rps)**2) - ((Fl(s-1,1)*Rps)**2))) -
     ?Fsol(s))*Fl(s,2))/fnorma 
     
    
      
      do j = s+1,fim
      
      tetass = dacos((Rpss**2 - ((Fl(j,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
      
      tetas = dacos((((Fl(j,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(j,1)*Rps)*Dcs))
      
      Fsol(j) =((Rpss**2)*tetass + ((Fl(j,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass)) 
      
      Fluxo(j) = (((pi*(((Fl(j,1)*Rps)**2) - ((Fl(j-1,1)*Rps)**2))) -
     ?Fsol(j) + Fsol(j-1))*Fl(j,2))/fnorma 
     
 
      end do 

      go to 555      
      else
      
      gama = 1.0d0
      go to 555
      
      end if
    
      end if
      
      end if
c--------------------------------------------*---------------	   
      else
    
      Fluxo(1) = 0.0d0
      si = 2

      
222   teste3 = dabs(Rpss - Dcs)

 
      
      if (teste3 .gt. (Fl(si,1)*Rps)) then
      
      Fluxo(si) = 0.0d0
      si = si + 1
      
      if (si .le. fim) then
      go to 222

      else
      go to 555
      end if
      
      else

      
      tetass = dacos((Rpss**2 - ((Fl(si,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
     
      tetas = dacos((((Fl(si,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(si,1)*Rps)*Dcs))
     
      Fsol(si) =((Rpss**2)*tetass + ((Fl(si,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass)) 
     
      Fluxo(si) = (((pi*((Fl(si,1)*Rps)**2))-
     ?Fsol(si))*Fl(si,2))/fnorma 
     
      if (si .lt. fim) then
      
      do jj = si+1,fim
      
      tetass = dacos((Rpss**2 - ((Fl(jj,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
      
      tetas = dacos((((Fl(jj,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(jj,1)*Rps)*Dcs))
      
      Fsol(jj) =((Rpss**2)*tetass + ((Fl(jj,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass))
      
      Fluxo(jj) =(((pi*(((Fl(jj,1)*Rps)**2) - ((Fl(jj-1,1)*Rps)**2)))-
     ?Fsol(jj) + Fsol(jj-1))*Fl(jj,2))/fnorma 
     
      end do	 
      go to 555
      
      else
      
      go to 555
      
      end if
     
      end if
	 
      end if	  
c=============================================================================      
      else
c-----------------------------------------------------------------------------

      tetass = dacos((Rpss**2 - ((Fl(1,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
      tetas = dacos((((Fl(1,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(1,1)*Rps)*Dcs))
      Fsol(1) =((Rpss**2)*tetass + ((Fl(1,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass))
c-----------------------------------------------------------------------------
      Fluxo(1) = (((pi*((Fl(1,1)*Rps)**2)) - Fsol(1))*Fl(1,2))/fnorma
      
              
      do i = 2,fim
      tetass = dacos((Rpss**2 - ((Fl(i,1)*Rps)**2) + 
     ?Dcs**2)/(2*Rpss*Dcs))
      tetas = dacos((((Fl(i,1)*Rps)**2) - Rpss**2 + 
     ?Dcs**2)/(2*(Fl(i,1)*Rps)*Dcs))
      Fsol(i) =((Rpss**2)*tetass + ((Fl(i,1)*Rps)**2)*tetas - 
     ?Dcs*Rpss*dsin(tetass)) 
      Fluxo(i) = (((pi*(((Fl(i,1)*Rps)**2) - ((Fl(i-1,1)*Rps)**2))) -
     ?Fsol(i) + Fsol(i-1))*Fl(i,2))/fnorma
      end do		    
      go to 555
      
      end if  
c==============================================================================      


555   continue
c==============================================================================

      do ss = 1,fim
      fluxo1 = fluxo1 + Fluxo(ss)
      end do

      gama = fluxo1

c      write(*,*)fnorma,fluxo1,gama
c      stop       
      end

c     subroutine penumbra (Dcs,Rpss,gama,Rps,Fl,num)
c    
c     Subroutine that calculate the gradual drop on the light flux in
c     the shadow

c     implicit none
c     
c     real*8 Dcs,Rpss,gama,fluxo,Rps,pi,tetass,tetas,Fnorma
c     
c     integer*4 iii,si,sii,m,ij,sj,sjj
c     
c     real*8 Fsol(100000),Fl(100000,2)

c     integer*4 num
c===============================================================================    
c     pi = 4*datan(1.0d0)    
c-------------------------------------------------------------------
c     fnorma = pi*((Fl(1,1)*Rps)**2)

c     do m = 2,num
c     Fnorma = fnorma + ((pi*(Fl(m,1)*Rps)**2) - 
c    ?(pi*(Fl(m-1,1)*Rps)**2))*Fl(m,2)
c     end do

c===================================================================       
c    
c     if (Dcs .ge. Rpss ) then
c    
c     if ((Dcs - Rpss) .gt. Fl(1,1)*Rps) then 
c     
c     fluxo = (pi*(Fl(1,1)*Rps)**2)*Fl(1,2)
c           
c     iii = 2
c     
c313   continue

c     if ((Dcs - Rpss) .ge. Fl(iii,1)*Rps) then 
c     
c     fluxo = fluxo+pi*((Fl(iii,1)*Rps)**2-
c    ?(Fl(iii-1,1)*Rps)**2)*Fl(iii,2)
c     
c     iii = iii+1
c     if (iii .lt. num) then        
c     go to 313
c     else 
c     go to 555
c     end if
c     else 
c    
c     tetass = dacos((Rpss**2 - (Fl(iii,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(iii,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(iii,1)*Rps)*Dcs))      
c     
c     Fsol(iii) = ((Rpss**2)*tetass + (((Fl(iii,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))      
c     
c     fluxo = (pi*((Fl(iii,1)*Rps)**2) - Fsol(iii))*Fl(iii,2)           

c     if (iii .lt. num) then 
c      
c     do si = iii,num
c
c     tetass = dacos((Rpss**2 - (Fl(si,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(si,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(si,1)*Rps)*Dcs))      
c     
c     Fsol(si) = ((Rpss**2)*tetass + (((Fl(si,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))    
c
c     
c     fluxo = fluxo + ((pi*((Fl(si,1)*Rps)**2 -(Fl(si-1,1)*Rps)**2))-
c    ?(Fsol(si) - Fsol(si-1)))*Fl(si,2)

c     end do
c     
c     go to 555
c     
c     else 
c     
c     go to 555
c     
c     end if 
c     
c     end if 
c     
c     else 

c     tetass = dacos((Rpss**2 - (Fl(1,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(1,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(1,1)*Rps)*Dcs))      
c     
c     Fsol(1) = ((Rpss**2)*tetass + (((Fl(1,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))         
c     
c     fluxo = (pi*(Fl(1,1)*Rps**2) - Fsol(1))*Fl(1,2)
c     
c     do sii = 2,num
c     
c     tetass = dacos((Rpss**2 - (Fl(sii,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(sii,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(sii,1)*Rps)*Dcs))      
c     
c     Fsol(sii) = ((Rpss**2)*tetass + (((Fl(sii,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))    
c
c     
c     fluxo = fluxo +((pi*((Fl(sii,1)*Rps)**2-(Fl(sii-1,1)*Rps)**2))-
c    ?(Fsol(sii) - Fsol(sii-1)))*Fl(sii,2)      
c    
c     end do
c     
c     end if 
c     
c     
c========================================================================      

c     else 
c     
c     if ((Rpss - Dcs) .gt. Fl(1,1)*Rps) then    
c     
c     
c     ij = 2
c     
c212   continue

c     if ((Rpss - Dcs) .gt. Fl(ij,1)*Rps) then  
c     
c     fluxo = fluxo + 0.0d0
c     
c     ij = ij+1
c           
c     if (ij .lt. num) then
c     go to 212
c     else
c     go to 555
c     end if
c     
c     else 

c     tetass = dacos((Rpss**2 - (Fl(ij,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(ij,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(ij,1)*Rps)*Dcs))      
c     
c     Fsol(ij) = ((Rpss**2)*tetass + (((Fl(ij,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))      
c     
c     fluxo = (pi*((Fl(ij,1)*Rps)**2) - Fsol(ij))*Fl(ij,2)
c     
c     if (ij .lt. num) then   
c     
c     do sj = ij,num
c   
c     tetass = dacos((Rpss**2 - (Fl(sj,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(sj,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(sj,1)*Rps)*Dcs))      
c     
c     Fsol(sj) = ((Rpss**2)*tetass + (((Fl(sj,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))   
c     
c     fluxo = fluxo + ((pi*((Fl(sj,1)*Rps)**2 -(Fl(sj-1,1)*Rps)**2))-
c    ?(Fsol(sj) - Fsol(sj-1)))*Fl(sj,2)
c     end do
c     
c     else 
c     
c     go to 555
c     
c     end if 
c     end if 
c     
c     else 
c     
c     tetass = dacos((Rpss**2 - (Fl(1,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(1,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(1,1)*Rps)*Dcs))      
c     
c     Fsol(1) = ((Rpss**2)*tetass + (((Fl(1,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))      
c         
c     fluxo = (pi*(Fl(1,1)*Rps)**2 - Fsol(1))*Fl(1,2)
c     
c     do sjj = 2,num
c     
c     tetass = dacos((Rpss**2 - (Fl(sjj,1)*Rps)**2 +
c    ?Dcs**2)/(2*Rpss*Dcs))      
c     
c     tetas = dacos(((Fl(sjj,1)*Rps)**2 - Rpss**2 + 
c    ?Dcs**2)/(2*(Fl(sjj,1)*Rps)*Dcs))      
c     
c     Fsol(sjj) = ((Rpss**2)*tetass + (((Fl(sjj,1)*Rps))**2)*tetas - 
c    ?Dcs*Rpss*dsin(tetass))  
c        
c     fluxo = fluxo + ((pi*((Fl(sjj,1)*Rps)**2-(Fl(sjj-1,1)*Rps)**2))-
c    ?(Fsol(sjj) - Fsol(sjj-1)))*Fl(sjj,2)
c     
c     end do
c     
c     go to 555
c     
c     end if 
c     
c     end if      
c     



c555   continue

c     if (fluxo .ge. 0.0d0) then
c     
c     if (fluxo/fnorma .le. 1.0d0) then

c     gama = fluxo/fnorma

c     else
c     
c     gama = 1.0d0
c       write(*,*)'flag',j,n,Dcs - Rpss
c  
c     end if
c     

c     else

c     gama = 0.0d0

c     end if

c     fluxo = 0.0d0



c      do j = 1,n
c      write(*,*) gama(j)
c      end do

c271   g = 2
c     continue
c     end





