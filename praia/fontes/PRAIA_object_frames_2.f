c
c
c     Program PRAIA_object_frames
c
c
c     Purpose
c
c
c
c     Given "xy" files generated by PRAIA, and object (RA,DEC)s, identifies
c     objects in all fits images where it appears and makes fits sub-frames
c     around them.      
c
c
c     In this version, the ds9 comand prompts are not used. Instead, our own
c     private routine is used to construct the fits sub-frame files.
c
c
c      Last update: Marcelo Assafin - 13/Jan/2010
c   
c
c
c


      IMPLICIT REAL *8 (A-H,O-Z)

      integer*2 bitpix

      character*50 ler

      character*50 list,raiz,output,filexy

c
c     Reading input batch file
c

      write (*,*)
      write (*,*) 
      write (*,*) 'PRAIA Object Frames'
      write (*,*) 
      write (*,*) 

c

c     open (77,file='PRAIA_object_frames_1.dat')

c
c
c

 1    continue

      read (*,*,end=200) key

      if (key.lt.1 .and. key.gt.2) then

      write (*,*) 'Input file type incorrect. Stop'
      stop

      endif


      read (*,10) list
      read (*,10) ler
      read (*,*) xbox,ybox
      read (*,*) xoff,yoff
      read (*,*) spixel
      read (*,*) ipflag
      read (*,*) bscale
      read (*,*) bzero
      read (*,*) bitpix
      read (*,*) kswap
      read (*,*)  ecom
      read (*,10) raiz
      read (*,10) output
      read (*,*)

      ibox=xbox/spixel
      iboy=ybox/spixel

      ixoff=xoff
      iyoff=yoff


 10   format (a50)

c     close (77)

c
c     Reads (RA,DEC)
c

      call dechex (ler,ra,de)



      if (key.eq.2) then
      filexy=list
      nfxy=1
      go to 25
      endif


c
c     Number of xy fields
c

      open (9,file=list)

      do i=1,100000000
      read (9,*,end=20)
      enddo

 20   nfxy=i-1

      rewind (9)


 25   continue

c


      if1=7
      if2=2

      open (if2,file=output)



c
c     Searches object in input file (xy file or target file)
c

      nob=0

      do 100 k=1,nfxy

      if (key.eq.1) read (9,10) filexy

      write (*,50) k,nfxy,filexy
 50   format('Searching file ',i5,' of ',i5,' : ',a50,' ...')

      open (if1,file=filexy)

      if (key.eq.1) call estat1 (raiz,nob,ipflag,bscale,bzero,
     ?kswap,bitpix,ecom,if1,if2,ra,de,ibox,iboy,ixoff,iyoff)
      if (key.eq.2) call estat2 (raiz,nob,ipflag,bscale,bzero,
     ?kswap,bitpix,ecom,if1,if2,ra,de,ibox,iboy,ixoff,iyoff)


      close (if1)


 100  continue

      close (if2)


      if (key.eq.1) close (9)

c
c     Continue to next search
c

      go to 1


c
c     That's all, folks!
c

 200  continue

      write (*,*) 
      write (*,*) 
      write (*,*) 'Execution terminated succesfully.'
      write (*,*) 
      write (*,*) 
      write (*,*) 

      end


c
c
c   
c     subroutine estat1
c
c     Retrives targets from xy files and output statistcs.
c
c     key    -> 1 = xy input file type                              
c
c     ecom   -> error box for (RA,DEC) identification (arcsec)
c
c     boxepo -> time error box for target identification
c
c     if1 -> xy file
c     if2 -> output of results
c
c
c     Last update: 13/Jan/2010  M. Assafin
c
c

      subroutine estat1 (raiz,nob,ipflag,bscale,bzero,
     ?kswap,bitpix,ecom,if1,if2,rafat,defat,ibox,iboy,ixoff,iyoff)


      IMPLICIT REAL *8 (A-H,O-Z)

      real*4 pixmat(5001,5001),pixel(5001,5001)
      integer*2 bitpix,betpix

      character*50 infits,raiz
      character*20 ichfil,mchobj,iobalv
      character*1 isig,menos
      character*60 subf

      character*69 ichobj

      common /a4/pixmat

      data menos/'-'/

      hmsgms(i,j,a)=i+j/60.d0+a/3600.d0

c

      PI    = 0.3141592653589793D1
      GRARAD=PI/180.D0
      RADGRA=180.D0/PI


c
c     (RA,DEC) box error
c

      box=ecom

c
c     Object search without time error box
c



 19   continue

      read (if1,10,err=19,end=200) xob,yob,seng,altu,fgcc,fumag,fumag2,
     ?xmgu,cudmg,cudmg2,xmgj,xmgh,xmgk,res2mg,resmg2,ermgj,ermgh,
     ?ermgk,pma,pmd,epma,epmd,ex,ey,erau,edeu,alfsiu,delsiu,
     ?nstaru,nfinau,alsiu,desiu,ktirau,ra,de,iuth,iutm,sut,iutano,
     ?iutmes,iutdia,dj,iexps,ichfil,infits,mchobj,nx,ny,ncom,aux,auy

 10   format(2(1x,f7.2),1x,f5.3,2(1x,f9.2),13(1x,f6.3),4(1x,f7.3),
     ?6(1x,f6.3),2(1x,i4),2(1x,f6.3),1x,i4,2(1x,f13.9),1x,i2,1x,i2,
     ?1x,f5.2,1x,i4,1x,i2,1x,i2,1x,f16.8,2x,i4,2x,a20,2x,a50,1x,a20,
     ?3(1x,i5),2(1x,f7.3))



c
c     Error box in (alpha,delta) for object identification
c


      dx=(ra-rafat)*dcos(defat*grarad)*3600.d0*15.d0
      dy=(de-defat)*3600.d0

      if (dabs(dx).gt.box) go to 19
      if (dabs(dy).gt.box) go to 19


c
c     Updates object information in output log file
c


      if (ncom.eq.0) ncom=1
c

      write (if2,11) dx,dy,xob,yob,seng,altu,fgcc,fumag,fumag2,
     ?xmgu,cudmg,cudmg2,xmgj,xmgh,xmgk,res2mg,resmg2,ermgj,ermgh,
     ?ermgk,pma,pmd,epma,epmd,ex,ey,erau,edeu,alfsiu,delsiu,
     ?nstaru,nfinau,alsiu,desiu,ktirau,ra,de,iuth,iutm,sut,iutano,
     ?iutmes,iutdia,dj,iexps,ichfil,infits,mchobj,nx,ny,ncom,aux,auy


 11   format(2(1x,f7.3),2(1x,f7.2),1x,f5.3,2(1x,f9.2),13(1x,f6.3),
     ?4(1x,f7.3),6(1x,f6.3),2(1x,i4),2(1x,f6.3),1x,i4,2(1x,f13.9),1x,
     ?i2,1x,i2,1x,f5.2,1x,i4,1x,i2,1x,i2,1x,f16.8,2x,i4,2x,a20,2x,a50,
     ?1x,a20,3(1x,i5),2(1x,f7.3))


c
c     Makes fits sub-frame for object     
c

      ixob=xob+ixoff
      iyob=yob+iyoff

c
c     Checks for fits image bondaries
c

      idx1=2*(ixob-1)+1
      idx2=2*(nx-ixob)+1

      idy1=2*(iyob-1)+1
      idy2=2*(ny-iyob)+1

      idx=min0(idx1,idx2)
      idy=min0(idy1,idy2)

      if (idx.gt.ibox) idx=ibox
      if (idy.gt.iboy) idy=iboy

c

      nob=nob+1

      subf=''
      subf=raiz

      do i=1,50
      if (subf(i:i).eq.' ') go to 13
      enddo

 13   continue

      write (subf(i:i+9),15) nob
 15   format(i5.5,'.fits')


c
c     Reads main fits file
c

      call refits (infits,nx,ny,nheads,ichobj,ipflag,bscale,bzero,
     ?kswap,iswap,bitpix)

c
c     Fills in sub-frame matrix
c

      idx=idx/2-1
      idy=idy/2-1

      ix1=ixob-idx
      ix2=ixob+idx

      iy1=iyob-idy
      iy2=iyob+idy

      j=0
      i=0

      do ii=iy1,iy2
      i=i+1
      j=0
      do jj=ix1,ix2
      j=j+1
      pixel(j,i)=pixmat(jj,ii)
      enddo
      enddo

      nx=j
      ny=i


c
c     Stores image sub-frame in fits format
c

      if=8
      betpix=32
      mswap=2
      scale=1.d0
      zero=0.d0


      call wfits (if,subf,bitpix,mswap,nx,ny,pixel,scale,zero)



 200  continue


      return
      end




c
c
c   
c     subroutine estat2
c
c     Retrives targets from offset target files and output statistcs.
c
c     key    -> 2 = offset input file type
c
c     ecom   -> error box for (RA,DEC) identification (arcsec)
c
c     boxepo -> time error box for target identification
c
c     if1 -> offset input file              
c     if2 -> output of results
c     if3 -> list of target input data
c
c
c     Last update: 13/Jan/2010  M. Assafin
c
c


      subroutine estat2 (raiz,nob,ipflag,bscale,bzero,
     ?kswap,bitpix,ecom,if1,if2,rafat,defat,ibox,iboy,ixoff,iyoff)



      IMPLICIT REAL *8 (A-H,O-Z)

      real*4 pixmat(5001,5001),pixel(5001,5001)
      integer*2 bitpix,betpix

      character*50 infits,raiz
      character*20 ichfil,mchobj,iobalv
      character*1 isig,menos
      character*60 subf
      character*69 ichobj

      common /a4/pixmat

      data menos/'-'/

      hmsgms(i,j,a)=i+j/60.d0+a/3600.d0

c

      PI    = 0.3141592653589793D1
      GRARAD=PI/180.D0
      RADGRA=180.D0/PI


c
c     (RA,DEC) box error
c

      box=ecom




c
c     Reads offset target file with observed (RA,DEC,JD)
c



 12   continue


      read (if1,11,err=12,end=200) zx,zy,xob,yob,seng,altu,fgcc,fumag,
     ?fumag2,xmgu,cudmg,cudmg2,xmgj,xmgh,xmgk,res2mg,resmg2,ermgj,ermgh,
     ?ermgk,pma,pmd,epma,epmd,ex,ey,erau,edeu,alfsiu,delsiu,
     ?nstaru,nfinau,alsiu,desiu,ktirau,ra,de,iuth,iutm,sut,iutano,
     ?iutmes,iutdia,dj,iexps,ichfil,infits,mchobj,nx,ny,ncom,aux,auy


c
c     Error box in (alpha,delta) for object identification
c


      dx=(ra-rafat)*dcos(defat*grarad)*3600.d0*15.d0
      dy=(de-defat)*3600.d0

      if (dabs(dx).gt.box) go to 12
      if (dabs(dy).gt.box) go to 12


c
c     Updates object information in output log file
c


      if (ncom.eq.0) ncom=1
c

      write (if2,11) dx,dy,xob,yob,seng,altu,fgcc,fumag,fumag2,
     ?xmgu,cudmg,cudmg2,xmgj,xmgh,xmgk,res2mg,resmg2,ermgj,ermgh,
     ?ermgk,pma,pmd,epma,epmd,ex,ey,erau,edeu,alfsiu,delsiu,
     ?nstaru,nfinau,alsiu,desiu,ktirau,ra,de,iuth,iutm,sut,iutano,
     ?iutmes,iutdia,dj,iexps,ichfil,infits,mchobj,nx,ny,ncom,aux,auy


 11   format(2(1x,f7.3),2(1x,f7.2),1x,f5.3,2(1x,f9.2),13(1x,f6.3),
     ?4(1x,f7.3),6(1x,f6.3),2(1x,i4),2(1x,f6.3),1x,i4,2(1x,f13.9),1x,
     ?i2,1x,i2,1x,f5.2,1x,i4,1x,i2,1x,i2,1x,f16.8,2x,i4,2x,a20,2x,a50,
     ?1x,a20,3(1x,i5),2(1x,f7.3))


c
c     Makes fits sub-frame for object     
c

      ixob=xob+ixoff
      iyob=yob+iyoff


c
c     Checks for fits image bondaries
c

      idx1=2*(ixob-1)+1 
      idx2=2*(nx-ixob)+1 

      idy1=2*(iyob-1)+1 
      idy2=2*(ny-iyob)+1

      idx=min0(idx1,idx2)
      idy=min0(idy1,idy2)


      if (idx.gt.ibox) idx=ibox
      if (idy.gt.iboy) idy=iboy

      idd=max0(idx,idy)


c

      nob=nob+1

      subf=''
      subf=raiz

      do i=1,50
      if (subf(i:i).eq.' ') go to 13
      enddo

 13   continue

      write (subf(i:i+9),15) nob
 15   format(i5.5,'.fits')


c
c     Reads main fits file
c

      call refits (infits,nx,ny,nheads,ichobj,ipflag,bscale,bzero,
     ?kswap,iswap,bitpix)

c
c     Fills in sub-frame matrix
c

      idx=idx/2-1
      idy=idy/2-1

      ix1=ixob-idx
      ix2=ixob+idx

      iy1=iyob-idy
      iy2=iyob+idy

      j=0
      i=0

      do ii=iy1,iy2
      i=i+1
      j=0
      do jj=ix1,ix2
      j=j+1
      pixel(j,i)=pixmat(jj,ii)
      enddo
      enddo

      nx=j
      ny=i


c
c     Stores image sub-frame in fits format
c

      if=8
      betpix=32
      mswap=2
      scale=1.d0
      zero=0.d0


      call wfits (if,subf,betpix,mswap,nx,ny,pixel,scale,zero)

c

      go to 12

c


 200  continue


      return
      end








c
c
c      Subroutine dechex
c
c
c      Interprets free (RA,DEC) input as decimal fraction or hexadecimal format
c      and returns (RA,DEC) as  decimal fraction format
c
c      Last update: Marcelo Assafin - 13 January 2010
c   
c
c

      subroutine dechex (ler,ra,de)


      IMPLICIT REAL *8 (A-H,O-Z)



      character*50 ler
      character*1 isig

      hmsgms(x,y,z)=x+y/60.d0+z/3600.d0

c

      idim=50

      dzero=0.d0
c

c
c     Reads input (RA,DEC) coordinates
c

 12   format(a50)


c
c     iflag = 1 :     hh.hhh  +/-dd.ddd  (ok)
c
c
c     iflag = 2 :     hh mm ss.sss +/-dg mm ss.ss -> hh.hhh  +/-dd.ddd 
c
c

      iflag=2

      do i=1,idim
      if (ler(i:i).ne.' ') go to 20
      enddo

 20   i1=i

      icont=0

      do i=i1,idim-1
      if (ler(i:i).ne.' '.and.ler(i+1:i+1).eq.' ') icont=icont+1
      enddo

      if (icont.lt.3) iflag=1


      if (iflag.eq.2) go to 30


c     
c     iflag = 1 case:   hh.hhh  +/-dd.ddd  ->  hh mm ss.sss +/-dg mm ss.ss
c



      read (ler,*) ra,de

      go to 50

c
c     iflag = 2 case:   hh mm ss.sss +/-dg mm ss.ss -> hh.hhh  +/-dd.ddd 
c


 30   continue


c
c     Checks declination sign
c

      isig='+'
      do i=i1,idim
      if (ler(i:i).eq.'-') isig='-'
      enddo


c
c     Case 1:  hh mm.mm +/-dg mm.mm  -> hh.hhh  +/-dd.ddd
c

      if (icont.eq.4) then

      read (ler,*) ah,am,dg,dm

      as=dzero
      ds=dzero

      endif

c
c     Case 2:  hh mm ss.sss +/-dg mm ss.sss  -> hh.hhh  +/-dd.ddd
c


      if (icont.eq.6) then

      read (ler,*) ah,am,as,dg,dm,ds

      endif

      dg=dabs(dg)

      ra=hmsgms(ah,am,as)
      de=hmsgms(dg,dm,ds)

      if (isig.eq.'-') de=-de

c

 50   continue

      return

      end




c
c     subrotine refits
c
c
c     Reads fits files (integer or floating point) in f77
c 
c
C      Last update:   27/08/2009 - Marcelo Assafin
C
C
      subroutine refits (infits,nx,ny,nheads,ichobj,ipflag,bscale,bzero,
     ?kswap,iswap,bitpix)



      IMPLICIT REAL *8 (A-H,O-Z)


      character*50 infits
      character*69 ichobj
      character*9  naxisx,naxisy,bitpx,ibscal,ibzero
      character*1  ler(2880),ibr
      character*9 iend,kend
      character*50 erro
      character*20 imaux
      character*4 jmaux
      character*9 sista
      character*29 systa

      dimension iwork2(1440),swork(2880),iby4(4)
      dimension work4(720),iwork4(720)
      dimension work8(360),iwork8(360)

      dimension pixmat(5001,5001)
      integer*2 bitpix

      real*4 pixmat
      integer*2 iwork2
      integer*4 iwork4
      real*4 work4
      integer*8 iwork8
      real*8 work8

      integer*1 swork,iby4

      common /a4/pixmat

      data naxisx /'NAXIS1  ='/
      data naxisy /'NAXIS2  ='/
      data bitpx  /'BITPIX  ='/
      data ibscal /'BSCALE  ='/
      data ibzero /'BZERO   ='/
      data iend   /'END      '/
      data ibr    /' '/

c

      nbytes=2880

      if=1

c
c     Abre arquivo fits
c

      

      open(if,file=infits,access='direct',form='unformatted',recl=2880)


c
c     Abre arquivo auxiliar
c

      sista='rm -f -r '

      imaux=''

      imaux(1:16)='PRAIA_refits.aux'


      do 1 i=1,9999

      write (jmaux,'(i4.4)') i

      imaux(17:20)=jmaux(1:4)

      open(99,file=imaux,access='direct',form='unformatted',
     ?recl=2880,status='old',err=2)
      close (99)
 1    continue

 2    close (99)

      open(99,file=imaux,access='direct',form='unformatted',
     ?recl=2880)

      systa=sista//imaux

c
c     Determina quantos headers existem na imagem
c

      kend=''

      m=0
 10   m=m+1
      read(if,rec=m) ler

      do j=0,35

      do i=1,9
      kend(i:i)=ler(j*80+i)
      enddo

      if (kend.eq.iend) go to 20

      enddo

      go to 10

c

 20   nheads=m

c     write (*,*)
c     write (*,*) 'nheads ',nheads
c     stop

c
c     Determina dimensao nx da matriz
c

      do i=1,nheads

      read(if,rec=i) ler

      call find (ler,naxisx,key,dnx)

      if (key.gt.0) nx=dnx

      enddo



c
c     Determina dimensao ny da matriz
c

      do i=1,nheads

      read(if,rec=i) ler

      call find (ler,naxisy,key,dny)

      if (key.gt.0) ny=dny

      enddo

c
c     Determina bitpix (imagem integer ou real?)
c

      if (bitpix.eq.-99) then

      bitpix=16

      do i=1,nheads

      read(if,rec=i) ler

      call find (ler,bitpx,key,bpix)

      if (key.gt.0) bitpix=bpix

      enddo

      endif


      i=bitpix
      if (i.lt.0) i=-i
      
      ibytes=i/8+0.1
      kwork=nbytes/ibytes+0.1



c
c     Determina bscale 
c

      if (ipflag.ne.1) then

      bscale=1.d0

      do i=1,nheads

      read(if,rec=i) ler

      call find (ler,ibscal,key,bsc)

      if (key.gt.0) bscale=bsc

      enddo

      endif


c
c     Determina bzero
c


      if (ipflag.ne.1) then

      bzero=0.d0

      do i=1,nheads

      read(if,rec=i) ler

      call find (ler,ibzero,key,bzr)

      if (key.gt.0) bzero=bzr

      enddo

      endif



c
c     Le a matriz de pixels
c


c
c     Checa byte-swap (litteendian ou bigendian)
c
c     kswap : chave do usuario
c
c          kswap = 0 determinacao automatica de byte-swap
c          kswap = 1 sem byte-swap (definido pelo usuario)
c          kswap = 2 com byte-swap (definido pelo usuario)
c
c     Determinacao automatica (kswap=0):
c
c     iswap=1  sem byte-swap
c     iswap=2  com byte-swap
c
c


      if (kswap.ne.0) then

      iswap=kswap

      go to 50

      endif


      irec=nheads+((nx*ny)/2.d0)*ibytes/nbytes 

c

      if (bitpix.gt.0) then

      if (ibytes.eq.2) read (if,rec=irec) iwork2
      if (ibytes.eq.4) read (if,rec=irec) iwork4
      if (ibytes.eq.8) read (if,rec=irec) iwork8

      else

      if (ibytes.eq.4) read (if,rec=irec) work4
      if (ibytes.eq.8) read (if,rec=irec) work8

      endif     

c
c     Media do valor absoluto sem swap
c

      c1=0.d0


      if (bitpix.gt.0) then

      do i=1,kwork
      if (ibytes.eq.2) c=bscale*iwork2(i)+bzero
      if (ibytes.eq.4) c=bscale*iwork4(i)+bzero
      if (ibytes.eq.8) c=bscale*iwork8(i)+bzero
      c1=c1+dabs(c)
      enddo

      c1=c1/kwork

      else

      do i=1,kwork
      if (ibytes.eq.4) c=bscale*work4(i)+bzero
      if (ibytes.eq.8) c=bscale*work8(i)+bzero
      c1=c1+dabs(c)
      enddo

      c1=c1/kwork

      endif


c
c     Testa com swap
c


      call swap (if,bitpix,ibytes,nbytes,irec,iwork2,iwork4,iwork8,
     ?work4,work8,swork)

c
c     Media do valor absoluto com swap
c

      c2=0.d0


      if (bitpix.gt.0) then

      do i=1,kwork
      if (ibytes.eq.2) c=bscale*iwork2(i)+bzero
      if (ibytes.eq.4) c=bscale*iwork4(i)+bzero
      if (ibytes.eq.8) c=bscale*iwork8(i)+bzero
      c2=c2+dabs(c)
      enddo

      c2=c2/kwork

      else

      do i=1,kwork
      if (ibytes.eq.4) c=bscale*work4(i)+bzero
      if (ibytes.eq.8) c=bscale*work8(i)+bzero
      c2=c2+dabs(c)
      enddo

      c2=c2/kwork

      endif

c
c     Define swap
c

      erro=''

      write (erro,*) c1

      do i=1,50
      if (ichar(erro(i:i)).ge.48 .and. ichar(erro(i:i)).le.57) go to 35
      enddo

      c1=1.d14

 35   continue

c

      erro=''
     
      write (erro,*) c2

      do i=1,50
      if (ichar(erro(i:i)).ge.48 .and. ichar(erro(i:i)).le.57) go to 40
      enddo

      c2=1.d14

 40   continue    

c

      if (c2.lt.c1) then
      iswap=2
      else
      iswap=1
      endif     


c     write (*,*) 'c1 c2 ',c1, c2

c
c     Lendo matriz
c

 50   continue


c

      block=nx*ny*ibytes/nbytes 
      nblock=block
      iresto=(block-nblock)*nbytes
      iresto=iresto/ibytes


      j=0
      i=1

      do m=1,nblock

      irec=m+nheads

c


      if (iswap.eq.1) then

      if (bitpix.gt.0) then

      if (ibytes.eq.2) read (if,rec=irec) iwork2
      if (ibytes.eq.4) read (if,rec=irec) iwork4
      if (ibytes.eq.8) read (if,rec=irec) iwork8

      else

      if (ibytes.eq.4) read (if,rec=irec) work4
      if (ibytes.eq.8) read (if,rec=irec) work8

      endif

      else

      call swap (if,bitpix,ibytes,nbytes,irec,iwork2,iwork4,iwork8,
     ?work4,work8,swork)

      endif

c

      if (bitpix.gt.0) then

      do mm=1,kwork

      j=j+1
      if (j.gt.nx) then
      j=1
      i=i+1
      endif

      if (ibytes.eq.2) pixmat(j,i)=bscale*iwork2(mm)+bzero
      if (ibytes.eq.4) pixmat(j,i)=bscale*iwork4(mm)+bzero
      if (ibytes.eq.8) pixmat(j,i)=bscale*iwork8(mm)+bzero

      enddo

      else

      do mm=1,kwork

      j=j+1
      if (j.gt.nx) then
      j=1
      i=i+1
      endif

      if (ibytes.eq.4) pixmat(j,i)=bscale*work4(mm)+bzero
      if (ibytes.eq.8) pixmat(j,i)=bscale*work8(mm)+bzero

      enddo      
 

      endif

      enddo

c
c     Ultimo pedaco de bloco da matriz (se existente)
c

      if (iswap.eq.1) then

      if (bitpix.gt.0) then

      if (ibytes.eq.2) read (if,rec=irec+1) (iwork2(m),m=1,iresto)
      if (ibytes.eq.4) read (if,rec=irec+1) (iwork4(m),m=1,iresto)
      if (ibytes.eq.8) read (if,rec=irec+1) (iwork8(m),m=1,iresto)

      else

      if (ibytes.eq.4) read (if,rec=irec+1) (work4(m),m=1,iresto)
      if (ibytes.eq.8) read (if,rec=irec+1) (work8(m),m=1,iresto)
     
      endif

      else

      nbytes=iresto*ibytes

      call swap (if,bitpix,ibytes,nbytes,irec,iwork2,iwork4,iwork8,
     ?work4,work8,swork)

      endif

c
      if (bitpix.gt.0) then

      do mm=1,iresto

      j=j+1
      if (j.gt.nx) then
      j=1
      i=i+1
      endif

      if (ibytes.eq.2) pixmat(j,i)=bscale*iwork2(mm)+bzero
      if (ibytes.eq.4) pixmat(j,i)=bscale*iwork4(mm)+bzero
      if (ibytes.eq.8) pixmat(j,i)=bscale*iwork8(mm)+bzero

      enddo      

      else

      do mm=1,iresto

      j=j+1
      if (j.gt.nx) then
      j=1
      i=i+1
      endif

      if (ibytes.eq.4) pixmat(j,i)=bscale*work4(mm)+bzero
      if (ibytes.eq.8) pixmat(j,i)=bscale*work8(mm)+bzero

      enddo      

      endif
c

      close (if)
      close (99)

c
c     Debug
c

c     read (*,*) j,i
c     j=100
c     i=101
c     write (*,*) 'ix iy = ',j,i
c     write (*,*) 'pixmat = ',pixmat(j,i)
c     write (*,*) 'nx ny ',nx,ny
c     write (*,*) 'swap ',iswap
c     write (*,*) 'c1 c2 = ',c1,c2
c     write (*,*) 'nheads = ',nheads
c     write (*,*) 'bitpix = ',bitpix
c     write (*,*) 'bscale = ',bscale
c     write (*,*) 'bzero  = ',bzero 
c     stop



      call system (systa)

c

      return
      end






c
c
c     subroutine find
c
c
c     Acha o valor numerico correspondente a palavra chave
c     do cabecalho fits
c
c     ler     = extracao do header 
c     word    = a palavra do header
c     key     = +1 achou
c             = -1 nao achou
c     valor   = valor numerico encontrado
c
c


      subroutine find (ler,word,key,valor)

      IMPLICIT REAL *8 (A-H,O-Z)
      

      character*1  ler(2880),iplic,ibr,ibar
      character*9  word,kend
      character*1 ivalor(71)



      data iplic /"'"/
      data ibar  /"/"/
      data ibr   /' '/

c

      key=-1
      valor=-1.d14

      icol=1
      id=71

c

      do j=0,35

      do i=1,9
      kend(i:i)=ler(j*80+i)
      enddo

      if (kend.eq.word) then
      key=+1
      go to 20
      endif

      enddo

      go to 50

c

 20   j=j*80
      do i=10,80
      if (ler(j+i).ne.ibr .and. ler(j+i).ne.iplic) go to 30
      enddo
 30   i1=i
      do i=i1+1,80
      if (ler(j+i).eq.ibr .or. ler(j+i).eq.ibar) go to 40
      enddo

 40   i2=i-1

c
      do i=1,id
      ivalor(i)=ibr
      enddo
c

      n=0

      do i=j+i1,j+i2
      n=n+1
      ivalor(n)=ler(i)
      enddo

c

      call chanum (icol,id,ivalor,valor)


 50   continue
      return

      end




c
c     subrotina chanum
c
c     Pega uma string (character) de numeros e extrai o numero da
c     coluna, sem abrir arquivos temporarios para isso.
c
c     string  = contem a string completa
c     palavra = variavel de trabalho contendo a string completa
c     b2 = contem o numero extraido correspondente a coluna dada
c     
c
c     Ultima modificacao: M. Assafin  27/Agosto/2009
c
c
c
      subroutine chanum (icol,id,string,valor)

      implicit real *8 (a-h,o-z)

      integer*8 n

      dimension ni(id+2),nf(id+2)

      character*1 string(id),palavra(id+2),ibra

c

      ibra=' '

c

      do i=1,id+2
      palavra(i)=ibra
      enddo

      do i=1,id
      palavra(i+1)=string(i)
      enddo

c
c     Checando colunas pelos espacos em branco
c

      do i=1,id
      ni(id)=0
      nf(id)=0
      enddo

      ki=0
      kf=0

c
c     Onde estah o comeco do numero
c

      do i=2,id+2

      if (palavra(i-1).eq.ibra .and. palavra(i).ne.ibra) then
      ki=ki+1
      ni(ki)=i
      endif

      enddo

c
c     Onde estah o fim do numero
c

      do i=2,id+2

      if (palavra(i-1).ne.ibra .and. palavra(i).eq.ibra) then
      kf=kf+1
      nf(kf)=i-1
      endif
      
      enddo

c
c     Checa se numero eh positivo ou negativo
c

      isig=+1

      i=ni(icol)
      if (palavra(i).eq.'-') isig=-1
  

c
c     Checa se numero estah escrito em notacao "E" ou "D"
c

      iep=0
      ie=0
      isige=+1


      do i=ni(icol),nf(icol)
      if (palavra(i).eq.'e'.or.palavra(i).eq.'E'.or.palavra(i).eq.'d'
     ?.or.palavra(i).eq.'D') ie=i
      enddo

      if (ie.ne.0) then

      iee=ie

      if (palavra(ie+1).eq.'-') then
      isige=-1
      endif

      if (palavra(ie+1).eq.'-'.or.palavra(ie+1).eq.'+') then
      ie=ie+2
      else
      ie=ie+1
      endif


      iep=0
      j=0
      k=nf(icol)-ie+1
      do i=ie,nf(icol)
      icomp=ichar(palavra(i))
      j=j+1
      iep=iep+(icomp-48)*10.d0**(k-j)
      enddo

      nf(icol)=iee-1

      endif

      expo=10.d0**(isige*iep)


c
c     Determina onde o ponto decimal estah, se nao for mumero inteiro
c

      m=0
      do i=nf(icol),ni(icol),-1
      if (palavra(i).eq.'.') m=i-nf(icol)
      enddo

c
c     Determina os algarismos do numero
c

      k=0
      do i=ni(icol),nf(icol)
      if (palavra(i).ne.'.' .and. palavra(i).ne.'+' .and. palavra(i).
     ?ne.'-') k=k+1
      enddo

      n=0
      j=0
      do i=ni(icol),nf(icol)
      icomp=ichar(palavra(i))
      if (icomp.ge.48 .and. icomp.le.57) then
      j=j+1
      n=n+(icomp-48)*10.d0**(k-j)
      endif
      enddo


      valor=expo*isig*n*10.d0**m

      return
      end




c
c
c     subroutine swap
c
c
c     Swap dos bytes da imagem fits.
c
c     Imagem pode ser integer ou floating point
c
c 
c     Ultima modificacao: M. Assafin 27/08/2009
c
c


      subroutine swap(if,bitpix,ibytes,nbytes,irec,iwork2,iwork4,iwork8,
     ?work4,work8,swork)


      IMPLICIT REAL *8 (A-H,O-Z)



      dimension iwork2(1440),swork(2880),iby4(4)
      dimension work4(720),iwork4(720)
      dimension work8(360),iwork8(360)

      integer*2 bitpix

      real*4 pixmat
      integer*2 iwork2
      integer*4 iwork4
      real*4 work4
      integer*8 iwork8
      real*8 work8

      integer*1 swork,iby4

c

      read (if,rec=irec) swork


      do k=ibytes,nbytes,ibytes

      do m=1,ibytes
      iby4(m)=swork(k-m+1)
      enddo

      do m=1,ibytes
      swork(k-ibytes+m)=iby4(m)
      enddo

      enddo

      write (99,rec=1) swork

      if (bitpix.gt.0) then

      if (ibytes.eq.2) read (99,rec=1) iwork2
      if (ibytes.eq.4) read (99,rec=1) iwork4
      if (ibytes.eq.8) read (99,rec=1) iwork8

      else

      if (ibytes.eq.4) read (99,rec=1) work4
      if (ibytes.eq.8) read (99,rec=1) work8

      endif     

c



c
      return
      end



c
c
c     Subroutine wfits
c
c     Writes a fits image given a matriz of pixels.
c
c
c     bitpix = 16  integer*2 data
c              +32 integer*4 data
c              -32 real*4 data
c              +64 integer*8 data
c              -64 real*8 data
c
c
c     iswap = 1 (do not swap image)
c             2 (swap image)
c
c
c
c
c     Last modified:   M. Assafin  18/Dec/2009
c

      subroutine wfits (if,file,bitpix,iswap,nx,ny,pixel,bscale,bzero)

      implicit real*8 (a-h,o-z)


      integer*2 iwork2(1440)
      integer*4 iwork4(720)
      integer*8 iwork8(360)
      real*4    rwork4(720)
      real*8    rwork8(360)

      integer*1 swork(2880),iby4(4)
      integer*2 bitpix

      real*4 pixel(5001,5001)

      character*60 file
      character*2880 header

      icab(il,ic)=(il-1)*80+ic


c
c     Initial data
c

      nbytes=2880

      if (bitpix.eq.16)  ibytes=2
      if (bitpix.eq.32)  ibytes=4
      if (bitpix.eq.-32) ibytes=4
      if (bitpix.eq.64)  ibytes=8
      if (bitpix.eq.-64) ibytes=8
      

c

      kwork=nbytes/ibytes


c
c     Opens fits file
c 


      open (if,file=file,access='direct',form='unformatted',
     ?recl=2880)



c
c     Writes fits header
c

      header=''

      l=1
      ic1=1
      ic2=46
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='SIMPLE  =                    T / Fits Standard'

      l=2
      ic1=1
      ic2=47
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='BITPIX  =                      / Bits per pixel'

      l=3
      ic1=1
      ic2=47
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='NAXIS   =                    2 / Number of axes'


      l=4
      ic1=1
      ic2=44
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='NAXIS1  =                      / Axis Length'


      l=5
      ic1=1
      ic2=44
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='NAXIS2  =                      / Axis Length'


      l=6
      ic1=1
      ic2=44
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='BSCALE  =                      / Data scale '


      l=7
      ic1=1
      ic2=44
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='BZERO   =                      / Zero point '


      l=2
      ic1=28
      ic2=30
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      write (header(ip1:ip2),'(i3)') bitpix


      l=4
      ic1=26
      ic2=30
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      write (header(ip1:ip2),'(i5)') nx

      l=5
      ic1=26
      ic2=30
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      write (header(ip1:ip2),'(i5)') ny


      l=6
      ic1=11 
      ic2=30
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      write (header(ip1:ip2),'(f20.10)') bscale


      l=7
      ic1=11 
      ic2=30
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      write (header(ip1:ip2),'(f20.10)') bzero 



      do l=8,35
      ic1=1
      ic2=41
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='COMMENTS=                      / Comments'
      enddo

      l=36
      ic1=1
      ic2=3
      ip1=icab(l,ic1)
      ip2=icab(l,ic2)
      header(ip1:ip2)='END'

      irec=1

      write (if,rec=irec) header

c
c     Now writes the data
c


      m=0

      do i=1,ny
      do j=1,nx

      m=m+1

c
      if (bitpix.eq.16) then
      iwork2(m)=pixel(j,i)
      if (m.eq.kwork) then
      irec=irec+1
      write (if,rec=irec) iwork2
      endif
      endif
c
      if (bitpix.eq.32) then
      iwork4(m)=pixel(j,i)
      if (m.eq.kwork) then
      irec=irec+1
      write (if,rec=irec) iwork4
      endif
      endif
c
      if (bitpix.eq.64) then
      iwork8(m)=pixel(j,i)
      if (m.eq.kwork) then
      irec=irec+1
      write (if,rec=irec) iwork8
      endif
      endif
c
      if (bitpix.eq.-32) then
      rwork4(m)=pixel(j,i)
      if (m.eq.kwork) then
      irec=irec+1
      write (if,rec=irec) rwork4
      endif
      endif
c
      if (bitpix.eq.-64) then
      rwork8(m)=pixel(j,i)
      if (m.eq.kwork) then
      irec=irec+1
      write (if,rec=irec) rwork8
      endif
      endif
c


      if (m.eq.kwork) then
      m=0
      if (iswap.eq.2) then
      call swapo (if,ibytes,nbytes,irec,swork)
      write (if,rec=irec) swork
      endif
      endif

      enddo
      enddo


      if (m.eq.0) go to 50

      irec=irec+1

      if (bitpix.eq.16) write (if,rec=irec) (iwork2(ii),ii=1,m)
      if (bitpix.eq.32) write (if,rec=irec) (iwork4(ii),ii=1,m)
      if (bitpix.eq.64) write (if,rec=irec) (iwork8(ii),ii=1,m)
      if (bitpix.eq.-32) write (if,rec=irec) (rwork4(ii),ii=1,m)
      if (bitpix.eq.-64) write (if,rec=irec) (rwork8(ii),ii=1,m)

      if (iswap.eq.2) then
      nbytes=m*ibytes
      call swapo (if,ibytes,nbytes,irec,swork)
      write (if,rec=irec) (swork(ii),ii=1,nbytes)
      endif

 50   continue


      close (if)


      return
      end



c
c
c     subroutine swapo
c
c
c     Swap bytes of pixel data
c
c     Image can by integer or floating point
c
c
c     Last modified: M. Assafin   18/Dec/2009
c


      subroutine swapo (if,ibytes,nbytes,irec,swork)

      IMPLICIT REAL *8 (A-H,O-Z)
      
      integer*1 swork(2880),iby4(4)

c

      read (if,rec=irec) swork


      do k=ibytes,nbytes,ibytes

      do m=1,ibytes
      iby4(m)=swork(k-m+1)
      enddo

      do m=1,ibytes
      swork(k-ibytes+m)=iby4(m)
      enddo

      enddo


c

      return
      end


