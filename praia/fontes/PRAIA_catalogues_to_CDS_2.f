c
c     PRAIA_catalogues_to_CDS
c
c
c     Formats complete catalog generated by the PRAIA_global_reduction,
c     filtered by possible multiple astrometric entries and with computed
c     proper motions using UCAC2, 2MASS and USNOB1 catalogs. The output is
c     in the CDS format for eletronic publication via CDS web service.
c
c
c     Entries are in crescent order in declination
c
c
c     In this version, JD is written full according to CDS standards.
c     Also, RA is written in degrees to comply with CDS standards too.
c
c
c     Usage:
c
c
c     PRAIA_catalogues_to_CDS < PRAIA_catalogues_to_CDS.dat > PRAIA_catalogues_to_CDS.log
c
c
c
C     Last update: M. Assafin - 22/Mar/2012
c
c


      IMPLICIT REAL *8 (A-H,O-Z)

      parameter(stdin=5,stdout=6,idim=1000001)


      dimension x(idim),y(idim),cseng(idim),altu(idim),
     ?fgcc(idim),fumag(idim),fumag2(idim),cxmgu(idim),
     ?codmg(idim),codmg2(idim),cxmgj(idim),cxmgh(idim),
     ?cxmgk(idim),res2mg(idim),resmg2(idim),ermgj(idim),
     ?ermgh(idim),ermgk(idim),copma(idim),copmd(idim)

      dimension epma(idim),epmd(idim),coex(idim),coey(idim),
     ?cerau(idim),cedeu(idim),alfsic(idim),delsic(idim),
     ?nstaru(idim),nfin(idim),alsiuc(idim),desiuc(idim),
     ?ktir(idim),oldra(idim),oldde(idim),kuth(idim),
     ?kutm(idim),zut(idim),kutano(idim),kutmes(idim),
     ?kutdia(idim),codj(idim),iexps(idim),ichfil(idim),
     ?mfits(idim),iobalv(idim),nx(idim),ny(idim),
     ?numcom(idim),egrxx(idim),egryy(idim),icat(idim),iflag(idim)

      dimension ior(idim)

      character*50 impcat,outcat

      character*20 ichfil,iobalv
      character*50 mfits


c
c     Reads from input file
c

      write (*,*)

 1    continue


      read (5,*,err=1,end=100) impcat,outcat
      write(6,*) impcat,outcat

      write (*,*)


c
c     Reads input complete original catalog generated by the
c     PRAIA package
c
c

      open (1,file=impcat)


      do i=1,idim

      read (1,10,end=15) x(i),y(i),cseng(i),altu(i),fgcc(i),fumag(i),
     ?fumag2(i),cxmgu(i),codmg(i),codmg2(i),cxmgj(i),cxmgh(i),cxmgk(i),
     ?res2mg(i),resmg2(i),ermgj(i),ermgh(i),ermgk(i),copma(i),copmd(i),
     ?epma(i),epmd(i),coex(i),coey(i),cerau(i),cedeu(i),alfsic(i),
     ?delsic(i),nstaru(i),nfin(i),alsiuc(i),desiuc(i),ktir(i),oldra(i),
     ?oldde(i),kuth(i),kutm(i),zut(i),kutano(i),kutmes(i),kutdia(i),
     ?codj(i),iexps(i),ichfil(i),mfits(i),iobalv(i),nx(i),ny(i),
     ?numcom(i),egrxx(i),egryy(i),icat(i),iflag(i)

 10   format(2(1x,f7.2),1x,f5.3,2(1x,f9.2),13(1x,f6.3),4(1x,f7.3),
     ?6(1x,f6.3),2(1x,i4),2(1x,f6.3),1x,i4,2(1x,f13.9),1x,i2,1x,i2,1x,
     ?f5.2,1x,i4,1x,i2,1x,i2,1x,f16.8,2x,i4,2x,a20,2x,a50,1x,a20,
     ?3(1x,i5),2(1x,f7.3),1x,2i1)

      enddo

 15   close (1)

      n=i-1


c
c     Orders entries by declination
c


      call ordem (n,ior,oldde)


c
c     Writes output catalog in CDS format
c

      open (7,file=outcat)


      do j=1,n

      i=ior(j)

      ra=oldra(i)*15.d0

      iegx=egrxx(i)*1000.01d0
      iegy=egryy(i)*1000.01d0

      if (dabs(egrxx(i)).gt.98.990d0) then
      iegx=999999
      iegy=999999
      endif


      ica=copma(i)*1000.01d0
      icd=copmd(i)*1000.01d0

      if (dabs(copma(i)).gt.98.990d0) then
      ica=999999
      icd=999999
      endif


      icx=coex(i)*1000.01d0
      icy=coey(i)*1000.01d0


      write (7,20) ra,oldde(i),codj(i),iegx,iegy,ica,icd,codmg(i),
     ?cxmgj(i),cxmgh(i),cxmgk(i),icx,icy,numcom(i),icat(i),iflag(i)

 20   format(2(1x,f13.9),1x,f16.8,4(1x,i6),4(1x,f6.3),2(1x,i5),1x,
     ?i2,2(1x,i1))


      
      enddo

      close (7)


      go to 1


c

 100  continue



      end





C
C
C     Subroutine ordem
C
C
C
C     Purpose
C
C       Orders data vectors in crescent value order.
C
C
C     Use
C
C     SUBROUTINE ORDEM (N,IOR,VAL)
C
C
C     Description of parameters
C
C       N      - number of points to be ordered
C       indx   - increasing order numbering of array "arr"
C       arr    - data array itself, NOT ORDERED
C
C
C     Subroutines and subprograms required
C
C
C
C     Comments
C           
C
C

      SUBROUTINE ordem(n,indx,arr)
      IMPLICIT REAL*8 (A-H,O-Z)

      INTEGER n,indx(n),M,NSTACK
      REAL*8 arr(n)
      PARAMETER (M=7,NSTACK=50)
      INTEGER i,indxt,ir,itemp,j,jstack,k,l,istack(NSTACK)

      REAL*8 a
      do 11 j=1,n
        indx(j)=j
11    continue
      jstack=0
      l=1
      ir=n
1     if(ir-l.lt.M)then
        do 13 j=l+1,ir
          indxt=indx(j)
          a=arr(indxt)
          do 12 i=j-1,1,-1
            if(arr(indx(i)).le.a)goto 2
            indx(i+1)=indx(i)
12        continue
          i=0
2         indx(i+1)=indxt
13      continue
        if(jstack.eq.0)return
        ir=istack(jstack)
        l=istack(jstack-1)
        jstack=jstack-2
      else
        k=(l+ir)/2
        itemp=indx(k)
        indx(k)=indx(l+1)
        indx(l+1)=itemp
        if(arr(indx(l+1)).gt.arr(indx(ir)))then
          itemp=indx(l+1)
          indx(l+1)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l)).gt.arr(indx(ir)))then
          itemp=indx(l)
          indx(l)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l+1)).gt.arr(indx(l)))then
          itemp=indx(l+1)
          indx(l+1)=indx(l)
          indx(l)=itemp
        endif
        i=l+1
        j=ir
        indxt=indx(l)
        a=arr(indxt)
3       continue
          i=i+1
        if(arr(indx(i)).lt.a)goto 3
4       continue
          j=j-1
        if(arr(indx(j)).gt.a)goto 4
        if(j.lt.i)goto 5
        itemp=indx(i)
        indx(i)=indx(j)
        indx(j)=itemp
        goto 3
5       indx(l)=indx(j)
        indx(j)=indxt
        jstack=jstack+2
c       if(jstack.gt.NSTACK)pause 'NSTACK too small in ordem'
        if(ir-i+1.ge.j-l)then
          istack(jstack)=ir
          istack(jstack-1)=i
          ir=j-1
        else
          istack(jstack)=j-1
          istack(jstack-1)=l
          l=i
        endif
      endif
      goto 1
      END


